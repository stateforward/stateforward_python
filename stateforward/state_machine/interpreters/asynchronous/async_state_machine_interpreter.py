"""

This module provides an interpreter for asynchronously executing a state machine defined using the `stateforward` library. The interpreter navigates the states and regions of the state machine, processes events, executes behaviors, and transitions between states based on events and guard conditions. It also manages timeouts, waits for change events, and more complex behaviors such as completion events and pseudostate handling.

Classes:
    AsyncStateMachineInterpreter(AsyncBehaviorInterpreter[T]): A class that extends `AsyncBehaviorInterpreter` for interpreting and executing state machine behaviors asynchronously.

This interpreter is designed to work with state machines that are asynchronous by nature or involve asynchronous operations. It leverages the `asyncio` library to provide a non-blocking execution approach. It contains various coroutines for processing different elements of a state machine such as events, regions, states, pseudostates, transitions, constraints, and more.

One can interact with the state machine by sending events and invoking the `run` method to start its execution. Exception handling is included where appropriate to ensure proper operation in the presence of invalid transitions or failed guard evaluations.

Note: Documentation automatically generated by https://undoc.ai
"""
import asyncio
from stateforward import elements, model
from stateforward.protocols.interpreter import InterpreterStep
from stateforward.state_machine.interpreters.asynchronous.async_behavior_interpreter import (
    AsyncBehaviorInterpreter,
)
import typing

T = typing.TypeVar("T", bound=elements.StateMachine)


class AsyncStateMachineInterpreter(AsyncBehaviorInterpreter[T]):
    """
    An asynchronous interpreter for state machine behaviors, executing different elements of a state machine
        such as states, regions, transitions, and events. It handles the active state configuration and
        performs the correct actions as dictated by the transitions, entry/exit behaviors, and event occurrences.
        The interpreter is designed to process the events and make the state machine evolve from one state to another
        asynchronously. It supports running and terminating a state machine.
        Attributes:
            Inherits all attributes from the AsyncBehaviorInterpreter class.
        Methods:
            async exec_event_processing(event):
                Processes an event for the state machine and manages the resulting state transitions.
            async exec_region_processing(region, event):
                Processes an event for a specific region within a state machine.
            async exec_state_processing(state, event):
                Processes an event for a specific state within a state machine.
            async exec_vertex_processing(vertex, event):
                Processes an event for a specific vertex within a state machine.
            async exec_transition_processing(transition, event):
                Processes an event for a specific transition within a state machine.
            async exec_constraint_evaluate_condition(constraint, event) -> bool:
                Evaluates the condition of a constraint in context of an occurred event.
            async exec_constraint_evaluate(constraint, event) -> bool:
                Evaluates a constraint and its relevance to an event.
            async exec_transition(transition, event=None):
                Executes a transition action associated with a state change in response to an event.
            async exec_vertex_exit(vertex, event):
                Manages the actions and steps required when exiting a vertex.
            async exec_transition_exit(transition):
                Manages the cleanup and state change associated with exiting a transition.
            async exec_vertex_entry(vertex, event, kind):
                Manages the entry actions into a vertex with the appropriate entry kind.
            async exec_final_state_entry(final_state, event):
                Defines the entry actions for a final state, to be implemented in derived classes.
            async exec_event_exit(event):
                Manages the cleanup and state change associated with an event termination.
            async exec_change_event_wait(event):
                Manages the waiting and sending of a change event.
            exec_change_event_entry(event):
                Creates and starts a task to wait for and send a change event.
            async exec_time_event_wait(event):
                Manages the waiting and sending of a time event after a specified duration.
            exec_time_event_entry(event):
                Creates and starts a task to wait for and send a time event.
            async exec_completion_event_wait(event):
                Manages the waiting and sending of a completion event once activities are completed.
            exec_completion_event_entry(event):
                Creates and starts a task to wait for and send a completion event.
            exec_event_entry(event):
                Routes event entry processing to the appropriate handler based on the event type.
            async exec_transition_entry(transition):
                Manages the actions and tasks required for entering a transition.
            async exec_state_entry(state, event, kind):
                Manages state entry actions, starting task for any associated behavior, and region entry processing.
            async exec_state_machine_entry(state_machine, event, kind):
                Manages state machine entry actions and region entry processing.
            async exec_region_entry(region, event, kind):
                Manages region entry and executes any initial pseudostate in default entry kind.
            async exec_region_exit(region, event):
                Manages region exit actions and exiting from active vertex.
            async exec_pseudostate_exit(psuedostate, event):
                Manages actions required when exiting a pseudostate, which is generally a no-op.
            async exec_state_exit(state, event):
                Manages actions and cleanup required for state exit.
            async exec_state_machine_exit(state_machine, event):
                Manages actions and cleanup for exiting the entire state machine.
            async exec_pseudostate_entry(pseudostate, event):
                Manages the entry into a pseudostate and performs associated transition behaviors.
            async run():
                Initiates the state machine execution by entering the state machine and progressing through steps.
            async terminate():
                Initiates termination of the state machine and any associated tasks.
    """

    async def exec_event_processing(self, event: elements.elements.Event):
        """
        Asynchronously processes an event across all regions in the model.
        This coroutine iterates through each region within the model and executes the event processing.
        It gathers the results of processing in each region concurrently using asyncio.gather.
        The method then determines the cumulative step result based on individual region results.
        If any region processing results in an InterpreterStep.complete, the overall
        result is subsequently InterpreterStep.complete. If not, the method checks for
        an InterpreterStep.deferred, which, if present, becomes the overall result.
        If neither complete nor deferred results are encountered, then the method
        returns InterpreterStep.incomplete as the final result.
        Args:
            event (elements.elements.Event): The event to be processed across all regions.
        Returns:
            InterpreterStep: An enumeration member representing the result of the event
                             processing across regions, which could be complete, deferred,
                             or incomplete.
        """
        results = await asyncio.gather(
            *(
                self.exec_region_processing(region, event)
                for region in self.model.regions
            )
        )
        if InterpreterStep.complete in results:
            return InterpreterStep.complete
        return (
            InterpreterStep.deferred
            if InterpreterStep.deferred in results
            else InterpreterStep.incomplete
        )

    async def exec_region_processing(
        self, region: elements.elements.Region, event: elements.elements.Event
    ):
        """
        Asynchronously processes a region for state machine execution.
        This coroutine checks if the given `region` is currently active. If it
        is not active, the processing is incomplete. When active, it identifies
        the active state within the region's subvertices and delegates the event
        processing to that state.
        Args:
            region (elements.elements.Region): The region of the state machine to process.
            event (elements.elements.Event): The event to be processed within the state machine.
        Returns:
            InterpreterStep: An enum value representing the completion status
                of the processing step, typically `InterpreterStep.incomplete`
                if the region or state is not active, or the result of
                `exec_state_processing` coroutine if an active state is found.
        Raises:
            TypeError: If the inputs are not of the expected type `elements.elements.Region`
                and `elements.elements.Event`.
        Note:
            The method assumes that the input types are as per the specifications.
            Any deviation might result in raising `TypeError` due to type incompatibility.
        """
        if not self.is_active(region):
            return InterpreterStep.incomplete
        active_state = next(
            (state for state in region.subvertex if self.is_active(state)), None
        )
        if active_state is None:
            return InterpreterStep.incomplete
        return await self.exec_state_processing(active_state, event)

    async def exec_state_processing(
        self, state: elements.elements.State, event: elements.elements.Event
    ):
        """
        Async function to process the provided state with respect to a given event.
            This function handles the execution of a state within a state machine. It checks if the state is active and then proceeds to process the regions within
            the state if they exist, by asynchronously awaiting the result of each region's processing. It aggregates the results and determines the
            outcome based on whether any region processing resulted in a complete step. If all regions result in incomplete processing or if there
            are no regions, it proceeds to process the state as a vertex.
            Args:
                state (elements.elements.State): The state of the state machine to process.
                event (elements.elements.Event): The event that triggers state processing.
            Returns:
                InterpreterStep: The result of the state processing, which could be `InterpreterStep.incomplete`
                if the processing is incomplete, or any other `InterpreterStep` value that signifies the outcome
                of processing the state or its regions.
            The function is designed to handle async workflows within state machine processing to ensure concurrency during the
            execution of state regions. It leverages asyncio's gather method to concurrently execute and wait for all region processing
            to complete, choosing the first complete result if available. If all regions return an incomplete result, the function defaults
            to processing the state itself. If the state also processes incompletely, it returns an incomplete result.
        """
        if not self.is_active(state):
            return InterpreterStep.incomplete
        elif state.regions is not None:
            result = next(
                (
                    result
                    for result in (
                        await asyncio.gather(
                            *(
                                self.exec_region_processing(region, event)
                                for region in state.regions
                            )
                        )
                    )
                    if result is not InterpreterStep.incomplete
                ),
                InterpreterStep.incomplete,
            )
        else:
            result = InterpreterStep.incomplete
        if result is InterpreterStep.incomplete:
            result = await self.exec_vertex_processing(state, event)
        return result

    async def exec_vertex_processing(
        self, vertex: elements.Vertex, event: elements.Event
    ):
        """
        Process a given vertex in the state machine by iterating through its outgoing transitions.
        This asynchronous method handles the processing of the specified vertex in the context of the current event. It
        iterates over all outgoing transitions from the given vertex and asynchronously processes each transition. If
        any transition processing results in a complete step (indicating that the transition conditions have been met
        and actions have been executed successfully), then the method terminates early, returning a status indicating
        that the step is complete. If none of the transitions result in a complete state, it returns a status
        indicating incomplete processing.
        Args:
            vertex (elements.Vertex): The vertex to be processed. It contains outgoing transitions that will be
                iterated and processed.
            event (elements.Event): The event that triggers the transitions. This event is used in the processing of
                transitions to determine whether the transition conditions are satisfied.
        Returns:
            InterpreterStep: An enumeration value representing the processing status after executing the
                outgoing transitions. It can either be InterpreterStep.complete if the processing of at least one
                transition is complete, or InterpreterStep.incomplete if all transitions result in incomplete processing.
        """
        for transition in vertex.outgoing:
            if (
                await self.exec_transition_processing(transition, event)
                == InterpreterStep.complete
            ):
                return InterpreterStep.complete
        return InterpreterStep.incomplete

    async def exec_transition_processing(
        self, transition: elements.Transition, event: elements.Event
    ):
        """
        Async function to execute the transition processing of a given state machine.
        This function checks whether the provided event matches any of the events
        specified in the transition events or if it is an instance of `elements.AnyEvent`. If the transition
        has a guard constraint, it also evaluates it. If both the event
        matching and guard evaluation (if any) pass, it then executes the transition.
        Args:
            transition (elements.Transition): The transition that needs to be processed.
            event (elements.Event): The event that potentially triggers the transition.
        Returns:
            InterpreterStep: An enumeration value indicating whether the step
            was `complete` if the transition was successfully executed,
            or `incomplete` if the transition was not executed.
        """
        if any(
            isinstance(_event, (type(event), elements.AnyEvent))
            for _event in transition.events
        ) and (
            transition.guard is None
            or await self.exec_constraint_evaluate(transition.guard, event)
        ):
            await self.exec_transition(transition, event)
            return InterpreterStep.complete
        return InterpreterStep.incomplete

        # could possibly improve this with using state in reverse

    async def exec_constraint_evaluate_condition(
        self, constraint: elements.Constraint, event: elements.Event
    ) -> bool:
        """
        Asynchronously evaluates a given constraint's condition using an event.
        Given a `constraint` object and an `event`, this coroutine executes the condition
        associated with the given constraint and assures the evaluation handles both
        synchronous and asynchronous results properly.
        The evaluation logic checks if the condition's result is an awaitable (future or coroutine)
        and asynchronously waits for it to resolve before logging the debug message with the result.
        If the condition's result is immediate (not awaitable), it proceeds to logging and
        returns the result synchronously.
        Args:
            constraint (elements.Constraint): The constraint object containing the condition to evaluate.
            event (elements.Event): The event argument passed to the constraint's condition function.
        Returns:
            bool: The result of the constraint's condition evaluation: True if the condition is met; False otherwise.
        Raises:
            Any exception raised by `constraint.condition(event)` or during the asynchronous execution will be propagated.
        """
        result = constraint.condition(event)
        if asyncio.isfuture(result) or asyncio.iscoroutine(result):
            result = await result
        self.log.debug(
            f"done evaluating constraint {model.qualified_name_of(constraint)} results are {result}"
        )
        return result

    async def exec_constraint_evaluate(
        self, constraint: elements.Constraint, event: elements.Event
    ) -> bool:
        """
        Asynchronously evaluates a constraint for a given event.
        This function performs an evaluation of a `constraint` within the context of a specific `event`. It logs the evaluation process at debug level, showing which constraint is being evaluated for which event, and then delegates the actual constraint condition evaluation to the `exec_constraint_evaluate_condition` method.
        Args:
            constraint (elements.Constraint): The constraint to be evaluated.
            event (elements.Event): The event in the context of which the constraint is to be evaluated.
        Returns:
            bool: The result of the constraint evaluation, `True` if the constraint is satisfied, otherwise `False`.
        """
        self.log.debug(
            f"evaluating constraint {model.qualified_name_of(constraint)} for event {model.qualified_name_of(event)}"
        )
        return await self.exec_constraint_evaluate_condition(constraint, event)

    async def exec_transition(
        self, transition: elements.Transition, event: elements.Event = None
    ):
        """
        Executes the given transition within a state machine, emitting log messages and managing vertex entries/exits.
        This asynchronous method is responsible for executing the full lifecycle of a state transition within
        a state machine (elements.Transition class instance). The method handles the logging of the transition
        execution, the orderly exiting of source vertices (leave), the execution of any transition effects, and
        the entry into target vertices (enter). Transition effects are executed if they are present. The method
        supports differentiated entry kinds, specifically 'default' and 'explicit', based on the vertices' position
        in the transition path.
        Args:
            transition (elements.Transition): The transition object to be executed.
            event (elements.Event, optional): The event object that triggered the transition, if any. Defaults to None.
        Raises:
            Anything that is raised during the execution of vertex exits, transition effects, or vertex entries.
        Notes:
            This method is an asynchronous coroutine, and should be called with 'await' from an async function.
        """
        self.log.debug(f"executing transition {model.qualified_name_of(transition)}")
        for vertex in transition.path.leave:
            await self.exec_vertex_exit(vertex, event)
        if transition.effect is not None:
            await self.exec_behavior(transition.effect, event)
        for index, vertex in enumerate(transition.path.enter):
            await self.exec_vertex_entry(
                vertex,
                event,
                elements.EntryKind.default
                if index == transition.path.enter.length - 1
                else elements.EntryKind.explicit,
            )

    async def exec_vertex_exit(self, vertex: elements.Vertex, event: elements.Event):
        """
        Asynchronous method to handle the exit execution of a vertex within a state machine.
        This method performs various operations based on the type of the vertex passed to it. If the vertex
        is of type `State`, it will asynchronously execute the exit of each outgoing transition from the
        state and then execute the state exit itself. If the vertex is not of type `State`, it is assumed
        to be a `Pseudostate`, and the method will accordingly execute the exit for a pseudostate.
        Additionally, it manages the state stack by popping off the current vertex. The actual popping mechanism
        is abstracted and is simply signified by the `pop` method call within the method body.
        Args:
            vertex (elements.Vertex): A vertex in the state machine, which can either be a `State` or a `Pseudostate`.
            event (elements.Event): The event that triggered the vertex exit.
        Returns:
            None: This method does not return any value, but it does perform async operations tied to the vertex exit.
        """
        if isinstance(vertex, elements.State):
            await asyncio.gather(
                *(
                    self.exec_transition_exit(transition)
                    for transition in vertex.outgoing
                )
            )
            await self.exec_state_exit(vertex, event)
        else:
            await self.exec_pseudostate_exit(
                typing.cast(elements.Pseudostate, vertex), event
            )
        self.pop(vertex)

    async def exec_transition_exit(self, transition: elements.Transition):
        """
        Async function to execute the exit process of a given state transition. It iterates through the events of the transition, as well as the transition itself, and removes those elements from a stack if they are present in it.
            Args:
                transition (elements.Transition): The transition whose exit execution is to be handled.
            Raises:
                TypeError: If any of the elements being popped is not present in the stack.
            Returns:
                None
        """
        for element in (*transition.events, transition.events, transition):
            if element in self.stack:
                self.pop(element)

    async def exec_vertex_entry(
        self, vertex: elements.Vertex, event: elements.Event, kind: elements.EntryKind
    ):
        """
        Executes entry logic for a given vertex in the state machine.
        This asynchronous method is responsible for handling the entry logic for vertices of different types including states, final states, and pseudostates. Upon calling, it triggers the entry actions for the state, handles transitions for state vertices, or processes the final state or pseudostate entry logic accordingly.
        Args:
            vertex (elements.Vertex): The vertex instance where the entry logic should be executed. Depending on the type of the vertex (state, final state, pseudostate), different entry actions are taken.
            event (elements.Event): The event instance that triggered the entry into the vertex. This parameter may influence conditional transitions or actions taken within the entry logic of the vertex.
            kind (elements.EntryKind): An enumeration that specifies the kind of entry being performed. This can help determine any special behaviors or actions that need to be taken depending on the entry kind.
        Returns:
            List: A list of results obtained from executing the entry logic for the vertex's outgoing transitions, pseudostate, or final state actions. The contents of this list depend on the type of vertex and the specific operations performed during entry.
        """
        self.push(vertex)
        if isinstance(vertex, elements.State):
            await self.exec_state_entry(vertex, event, kind)
            results = await asyncio.gather(
                *(
                    self.exec_transition_entry(transition)
                    for transition in vertex.outgoing
                )
            )

        elif isinstance(vertex, elements.FinalState):
            results = await self.exec_final_state_entry(vertex, event)
        else:
            results = await self.exec_pseudostate_entry(
                typing.cast(elements.Pseudostate, vertex), event
            )
        return results

    async def exec_final_state_entry(
        self, final_state: elements.FinalState, event: elements.Event
    ):
        """
        Asynchronously execute the entry action for the final state of a state machine.
        This method should be implemented to carry out the entry action associated with the
        final state when the state machine reaches its conclusion. The method is
        designed to be overridden as it raises NotImplementedError by default.
        Args:
            final_state (elements.FinalState): The final state object for which the entry action
                needs to be executed.
            event (elements.Event): The event that triggered the entry into the final state.
        Raises:
            NotImplementedError: If the method has not been implemented.
        """
        raise NotImplementedError()

    async def exec_event_exit(self, event: elements.Event):
        """
        Async method to handle the exit of an event in the state machine.
        This method asynchronously executes the necessary operations to pop an event
        from the state machine's event stack. It should be called when an event needs
        to be terminated or concluded within the state machine's execution flow.
        Args:
            event (elements.Event): The event to be removed from the stack.
        """
        self.pop(event)

    async def exec_change_event_wait(self, event: elements.ChangeEvent):
        """
        Async function to continually check a given change event's expression and send the event once the expression is fulfilled.
            This function enters an infinite loop, repeatedly evaluating the provided event's expression. If the expression evaluates to True, the function will send the class instance of the event and break the loop. Otherwise, it will asynchronously sleep with a delay of 0 seconds to effectively yield execution and continue checking the expression.
            Args:
                event (elements.ChangeEvent): An instance of ChangeEvent containing the expression to evaluate.
            Raises:
                Any exceptions raised from `send` or `event.expr` are propagated upwards.
            Returns:
                None: This function only acts to send the event and does not provide an explicit return value.
        """
        while True:
            if event.expr(event):
                await self.send(event.__class__())
                break
            await asyncio.sleep(0)

    def exec_change_event_entry(self, event: elements.ChangeEvent):
        """
        Executes the entry action for a given change event asynchronously.
            This method is responsible for initiating the execution of the action associated with
            a change event. It creates an asyncio task to run the event action, allowing
            the event execution to be scheduled and managed by the asyncio event loop. The task
            is named using the qualified name of the event from the model for easy identification.
            Args:
                event (elements.ChangeEvent): The change event instance whose entry action needs to be executed.
            Returns:
                asyncio.Task: The asyncio task object that represents the scheduled event action execution.
            Raises:
                AttributeError: If the `model` attribute doesn't have the `qualified_name_of` method.
        """
        return asyncio.create_task(
            self.exec_change_event_wait(event), name=model.qualified_name_of(event)
        )

    async def exec_time_event_wait(self, event: elements.TimeEvent):
        """
        Asynchronously wait for a specified time before sending a time event.
        This coroutine function introduces a delay equal to the total number of seconds specified in the
        `event`'s `when` attribute, then sends an instance of the event's class to signify that the
        time event has occurred.
        Args:
            event (elements.TimeEvent): The time event object containing the 'when' attribute, which
                specifies the duration to wait before triggering the event.
        """
        await asyncio.sleep(event.when.total_seconds())
        await self.send(event.__class__())

    def exec_time_event_entry(self, event: elements.TimeEvent):
        """
        Executes a time-based event entry asynchronously by creating a task that awaits the execution of the event.
            This method is responsible for initializing the asynchronous execution of a given time event associated with the state machine.
            It creates a named asyncio task that will wait for the time event to occur.
            Args:
                event (elements.TimeEvent): The time event to be executed.
            Returns:
                asyncio.Task: The asyncio Task object created for the time event execution.
            Note:
                The name of the asyncio task is derived from the qualified name of the event obtained through `model.qualified_name_of(event)`.
        """
        return asyncio.create_task(
            self.exec_time_event_wait(event), name=model.qualified_name_of(event)
        )

    async def exec_completion_event_wait(self, event: elements.CompletionEvent):
        """
        Asynchronously waits for an event to complete and handles associated activities.
        This async method takes a completion event and processes it, with the goal of
        waiting for a specified activity ('source') associated with the event to
        complete. It performs the following steps:
        1. Identifies the owning state of the event passed as an argument and associates
           it with 'source'.
        2. Retrieves a future associated with the 'source' activity from the execution
           stack.
        3. Waits for the future to resolve and assigns its resolved value to the event.
        4. Generates a tuple of futures for all descendant activities of 'source' that
           have a state sub-type, indicating that they are part of the currently
           executing model.
        5. Concurrently awaits all these futures using `asyncio.gather` to ensure they
           are processed completely.
        6. Pushes the event onto the execution stack once all futures have been resolved.
        Args:
            event (elements.CompletionEvent): The completion event that is to be
                processed by the method.
        Raises:
            Any exceptions raised by `asyncio.gather` or related coroutine executions
            will be propagated to the caller of this method.
        """
        source: elements.State = model.owner_of(event)
        future = self.stack.get(source.activity)
        event.value = await future
        activities = tuple(
            self.stack.get(typing.cast(elements.State, state).activity)
            for state in self.stack
            if model.element.is_subtype(state, elements.State)
            and model.element.is_descendant_of(source, state)
        )
        await asyncio.gather(*activities)
        self.push(event)

    def exec_completion_event_entry(self, event: elements.CompletionEvent):
        """
        Executes the completion event's entry logic and initiates an asynchronous wait task for it.
        Args:
            event (elements.CompletionEvent): The completion event to enter and process.
        Returns:
            asyncio.Task: An asynchronous task associated with the execution and wait of the completion event.
        This method logs the entry into a completion event with its qualified name and sets the event's value to None.
        It then creates an asyncio task to handle the execution and waiting process of the completion event, naming the task with the event's qualified name.
        """
        qualified_name = model.qualified_name_of(event)
        self.log.debug(f"entering completion event {qualified_name}")
        event.value = None
        task = asyncio.create_task(
            self.exec_completion_event_wait(event), name=qualified_name
        )
        return task

    def exec_event_entry(self, event: elements.Event):
        """
        Handles the entry of an event by triggering the appropriate event-specific handler.
        This method determines the type of event that is being entered and calls the respective handler for that event type.
        Args:
            event (elements.Event): The event to be handled which can be of type TimeEvent, CompletionEvent, or ChangeEvent.
        Returns:
            The result of calling the event-specific handler function. The return type depends on which handler is called.
        Raises:
            AttributeError: If `qualified_name_of` method does not exist on the model.
            TypeError: If the event is not an instance of the supported event types (TimeEvent, CompletionEvent, ChangeEvent).
        """
        qualified_name = model.qualified_name_of(event)
        self.log.debug(f"entering event {qualified_name}")
        if isinstance(event, elements.TimeEvent):
            return self.exec_time_event_entry(event)

        elif isinstance(event, elements.CompletionEvent):
            return self.exec_completion_event_entry(event)

        elif isinstance(event, elements.ChangeEvent):
            return self.exec_change_event_entry(event)

    async def exec_transition_entry(self, transition: elements.Transition):
        """
        Execute actions associated with the entry to a transition.
        This coroutine method is responsible for executing the entry behavior of a transition
        in the state machine. It logs the entrance, pushes the transition onto a stack, and
        then creates and awaits tasks for each event associated with the transition.
        Args:
            transition (elements.Transition): The transition object representing the transition
                being entered within the state machine.
        Notes:
            - This method assumes that the object has a 'log' attribute with a 'debug' method
              capable of logging debug messages.
            - It also assumes the existence of the 'push' method to put the transition and its
              events onto a stack, and the 'wait' coroutine to await the completion of tasks.
            - The 'exec_event_entry' method should be defined, which returns a coroutine
              task for each event; if it returns None, the event is not awaited.
        """
        qualified_name = model.qualified_name_of(transition)
        self.log.debug(f"entering transition {qualified_name}")
        self.push(transition)
        tasks = []
        for event in transition.events:
            task = self.exec_event_entry(event)
            if task is not None:
                tasks.append(task)
        if tasks:
            self.push(
                transition.events,
                self.wait(*tasks),
            )

    async def exec_state_entry(
        self, state: elements.State, event: elements.Event, kind: elements.EntryKind
    ):
        """
        Asynchronously execute the entry actions for a given state in the state machine.
        This function handles the entry actions for the state passed as an argument as well as starting the
        activities and dealing with submachine states. It is also responsible for initiating the entry actions
        of any regions within the state.
        Args:
            state (elements.State): The state for which entry actions are to be executed.
            event (elements.Event): The event that triggered the state transition.
            kind (elements.EntryKind): The kind of entry action to be executed.
        Raises:
            Exception: If any of the executed behaviors raises an exception.
        Note:
            This function is a coroutine and should be called with 'await' from an async function.
        """
        qualified_name = model.qualified_name_of(state)
        self.log.debug(f"entering state {qualified_name}")
        if state.entry is not None:
            await self.exec_behavior(state.entry, event)
        if state.activity is not None:
            self.push(
                state.activity,
                self.loop.create_task(self.exec_behavior(state.activity, event)),
            )
        if state.submachine is not None:
            return
        await asyncio.gather(
            *(
                self.exec_region_entry(region, event, kind)
                for region in state.regions or []
            )
        )

    async def exec_state_machine_entry(
        self,
        state_machine: "elements.StateMachine",
        event: typing.Optional[elements.Event],
        kind: elements.EntryKind,
    ):
        """
        Executes the entry logic for a given state machine within the elements framework.
        This asynchronous method triggers entry actions for each region associated with the provided state machine. It logs the state machine entry and performs the necessary entry operations as an asynchronous task for each region, using asyncio.gather to run them concurrently.
        Args:
            state_machine (elements.StateMachine): The state machine for which the entry logic needs to be executed.
            event (typing.Optional[elements.Event]): The event that led to the state machine entry, if any. Can be None.
            kind (elements.EntryKind): The kind of entry being performed, determining the execution behavior for the entry actions.
        Returns:
            list: A list of results from the execution of entry logic of each region in the state machine. It is the collection of returned values from executing entry logic for all the regions.
        """
        self.log.debug(
            f'entering state machine "{model.qualified_name_of(state_machine)}" with {state_machine.regions.length} regions'
        )
        return await asyncio.gather(
            *(
                self.exec_region_entry(region, event, kind)
                for region in state_machine.regions
            )
        )

    async def exec_region_entry(
        self, region: elements.Region, event: elements.Event, kind: elements.EntryKind
    ):
        """
        Asynchronously execute entry actions for a region based on the provided entry kind.
        This method is responsible for managing the entry behavior of a region within the state machine. It handles
        the execution of actions associated with the entry of a region and pushes the region onto the execution stack.
        The behavior differs based on whether a default entry or another kind of entry (as defined by `elements.EntryKind`)
        is requested.
        If `elements.EntryKind.default` is passed as the entry kind and the region contains an initial pseudostate,
        the method will recursively execute entry actions starting from the region's initial pseudostate. For other kinds
        of entry, no specific action is executed apart from pushing the region onto the stack.
        Args:
            region (elements.Region): The region object to which entry actions should be applied.
            event (elements.Event): The event instance that triggered the entry action.
            kind (elements.EntryKind): The kind of entry action to execute, which can be `elements.EntryKind.default` or others.
        Returns:
            Coroutine[Any, Any, Tuple]: A coroutine that when awaited, returns a tuple representing the states entered
                                       as a result of executing the entry action for the region.
        """
        qualified_name = model.qualified_name_of(region)
        self.log.debug(f"entering region {qualified_name}")
        states = ()
        if kind == elements.EntryKind.default:
            if region.initial is None:
                return states
            self.push(region)
            return await self.exec_pseudostate_entry(region.initial, event)
        self.push(region)
        return states

    async def exec_region_exit(self, region: elements.Region, event: elements.Event):
        """
        Asynchronously execute the exit behavior of a given region.
        This coroutine is responsible for managing the transition of exiting a region
        in the state machine. It first logs the action, then finds and triggers the
        exit behavior of the currently active vertex within the region, and finally
        removes the region from the internal stack.
        Args:
            region (elements.Region): The region object that is to be exited.
            event (elements.Event): The event instance that might trigger state transitions.
        Note:
            This coroutine is a low-level part of the state machine execution flow.
            It relies on the existence of 'self.log' for logging, and the correct
            functioning of 'self.exec_vertex_exit' and 'self.pop' methods.
        """
        qualified_name = model.qualified_name_of(region)
        self.log.debug(f'leaving region "{qualified_name}"')
        active_vertex = next(
            (vertex for vertex in region.subvertex if vertex in self.stack),
            None,
        )
        if active_vertex is not None:
            await self.exec_vertex_exit(active_vertex, event)
        self.pop(region)

    async def exec_pseudostate_exit(
        self, psuedostate: elements.Pseudostate, event: elements.Event
    ):
        """
        Async function to execute the exit behavior of a given pseudostate in response to an event.
        Args:
            psuedostate (elements.Pseudostate): The pseudostate from which the exit behavior should be executed.
            event (elements.Event): The event that triggers the exit behavior of the pseudostate.
        Returns:
            None
        Raises:
            - Exceptions related to failures in executing the exit behavior.
              The specific exceptions depend on the implementation of the pseudostate's exit behavior.
        """
        pass

    async def exec_state_exit(self, state: elements.State, event: elements.Event):
        """
        Asynchronously executes the exit actions of a given state during a state machine transition.
        This coroutine, when invoked with a specific `state` and an `event`, carries out the necessary
        actions to gracefully exit the given state. This includes exiting any submachine the state
        might have, exiting its child regions (if any), cancelling any ongoing activities associated
        with the state, and finally, executing any exit behavior defined for that state.
        Args:
            state (elements.State): The state object from which to perform the exit procedure.
            event (elements.Event): The event that triggered the transition, used when executing
                the exit behavior.
        Raises:
            asyncio.CancelledError: If the exit process is cancelled during its execution,
                typically when the ongoing activity of the state is interrupted.
        Notes:
            This coroutine method must be awaited when called. It is responsible for ensuring that
            all state exit-related behaviors and subprocesses are correctly and fully executed.
            It provides debug logging that outputs the qualified name of the state being exited,
            which could be useful for tracing the state transitions in the state machine execution.
        """
        qualified_name = model.qualified_name_of(state)
        if state.submachine is not None:
            await self.exec_state_machine_exit(state.submachine, event)
        else:
            await asyncio.gather(
                *(
                    self.exec_region_exit(region, event)
                    for region in state.regions or []
                )
            )
        if state.activity is not None:
            activity = self.pop(state.activity)
            if not activity.done():
                activity.cancel()
        if state.exit is not None:
            await self.exec_behavior(state.exit, event)
        self.log.debug(f'leaving state "{qualified_name}"')

    async def exec_state_machine_exit(
        self,
        state_machine: "elements.StateMachine",
        event: typing.Optional[elements.Event],
    ):
        """
        Async function to execute the exit of a state machine and its regions.
        This method logs the process of leaving a state machine and then concurrently
        calls the exec_region_exit method for each of the state machine's regions to handle
        their respective exits.
        Args:
            state_machine (elements.StateMachine): The state machine instance that is being exited.
            event (typing.Optional[elements.Event]): An optional event that may be associated
                with the state machine exit. If no event is provided, None is used.
        Returns:
            None: This method does not return anything.
        Raises:
            Any exceptions raised during the exit of regions are propagated up to the caller.
        """
        self.log.debug(
            f'leaving state machine "{model.qualified_name_of(state_machine)}"'
        )
        await asyncio.gather(
            *(self.exec_region_exit(region, event) for region in state_machine.regions)
        )

    async def exec_pseudostate_entry(
        self, pseudostate: elements.Pseudostate, event: elements.Event
    ):
        """
        Asynchronously executes an entry action for a given pseudostate in the state machine.
        This coroutine handles the behavior associated with different types of pseudostates during
        the state transition process. Based on the kind of the pseudostate, it takes appropriate
        action for 'initial', 'choice', 'join', or 'fork' pseudostates. For instance, it may
        initiate a transition, evaluate transition guards, or handle multiple concurrent transitions
        in the case of a fork pseudostate.
        Args:
            pseudostate (elements.Pseudostate): The pseudostate from which to execute the entry.
            event (elements.Event): The event that triggered the transition if any.
        Raises:
            Exception: When no valid transition can be found for a choice pseudostate.
            Exception: If other unspecified exceptions are encountered during the execution.
        Returns:
            Coroutine[Any]: The coroutine that will perform the transition associated with the pseudostate.
        """
        self.log.debug(
            f"entering {pseudostate.kind.value} psuedostate {model.qualified_name_of(pseudostate)}"
        )
        if pseudostate.kind == elements.PseudostateKind.initial:
            return await self.exec_transition(pseudostate.outgoing[0], event)
        elif pseudostate.kind == elements.PseudostateKind.choice:
            for transition in pseudostate.outgoing:
                if transition.guard is None or await self.exec_constraint_evaluate(
                    transition.guard, event
                ):
                    return await self.exec_transition(transition, event)
            raise Exception("no valid transition this should never throw")
        elif pseudostate.kind == elements.PseudostateKind.join:
            if all(
                transition.source not in self.stack
                for transition in pseudostate.incoming
            ):
                return await self.exec_transition(pseudostate.outgoing[0], event)
        elif pseudostate.kind == elements.PseudostateKind.fork:
            return await asyncio.gather(
                *(
                    self.exec_transition(transition, event)
                    for transition in pseudostate.outgoing
                )
            )

    async def run(self):
        """
        Asynchronously executes the state machine associated with this instance.
        This method wraps the state machine execution process with logging, initialization, and the execution of a single step. It then proceeds to call its superclass's `run` method to possibly continue the execution. The qualified name of the state machine model is logged before commencement.
        The method performs the following steps in order:
        1. Logs the commencement of the state machine using its qualified name.
        2. Triggers the execution of the state machine's entry point, which might involve initialization procedures.
        3. Calls the `step` method, which is expected to execute a single step or transition of the state machine.
        4. Calls and awaits the `run` method of the superclass to potentially perform further actions or continue the execution of the state machine.
        Returns:
            The result of the superclass's `run` method, which could be the final state of the state machine or indicate completion.
        """
        self.log.debug(f'running state machine "{model.qualified_name_of(self.model)}"')
        await self.exec_state_machine_entry(
            self.model, None, elements.EntryKind.default
        )
        await self.step()
        return await super().run()

    async def terminate(self):
        """
        Async function to terminate the current state machine and call the termination method of the parent class.
            This function handles the termination process of the current state machine instance by first ensuring
            that the state machine exits properly using the `exec_state_machine_exit` method with the current model
            and a `None` context. After handling the state exit, it calls the terminate method of the superclass to
            perform any additional termination steps defined in the parent class.
            This method is asynchronous and must be awaited when called.
            Raises:
                It inherits any exceptions that might be raised by `exec_state_machine_exit` or the superclass
                `terminate` method, as this method does not explicitly include exception handling.
        """
        await self.exec_state_machine_exit(self.model, None)
        await super().terminate()
