"""

Asynchronous Behavior Interpreter Module.

This module provides classes and functions to interpret and handle asynchronous
behaviors within a state machine. It leverages asyncio to manage concurrent
execution of state behaviors and events.

Classes:
    AsyncBehaviorInterpreter(AsyncInterpreter, clock=Clock)
        An interpreter for asynchronous behavior execution within a state
        machine model. It extends the AsyncInterpreter and uses a Clock
        instance for time-related operations.

        Attributes:
            deferred (list[elements.Event]): A list of events that have been deferred
during processing.

        Methods:
            __init__(self, queue: Queue=None, log: Logger=None)
                Initializes AsyncBehaviorInterpreter with a specified queue for events
                and a logger.

            step(self)
                Processes the events in the queue asynchronously, executing relevant
                behaviors and managing deferred events.

            exec_behavior(self, behavior: elements.Behavior, event: typing.Optional[elements.Event])
                Executes a given behavior associated with an event.

            exec_event_processing(self, event: elements.Event) -> InterpreterStep
                Abstract method for processing an event within the state machine.
                Must be implemented by subclasses.

Functions:
    None

Additional Notes:
    This module requires that users of AsyncBehaviorInterpreter implement the
    exec_event_processing method to define specific logic for event processing.
    The module is designed to work within the stateforward package's
    state machine framework, and it requires the elements and model modules
    from stateforward for defining and working with state machine components
    and behaviors.

Note: Documentation automatically generated by https://undoc.ai
"""
from stateforward import elements, model
import typing
import asyncio

from stateforward.state_machine.log import create_logger
from stateforward.protocols.logger import Logger
from stateforward.protocols.interpreter import InterpreterStep
from stateforward.state_machine.clocks import Clock
from stateforward.protocols import Queue
from stateforward.state_machine.interpreters.asynchronous.async_interpreter import (
    AsyncInterpreter,
)


class AsyncBehaviorInterpreter(AsyncInterpreter, clock=Clock):
    """
    Class representing an asynchronous interpreter that processes behaviors and events within a model.
        This class extends AsyncInterpreter and includes a clock, handling the queueing and deferred execution
        of events. It is responsible for executing behaviors associated with each event and managing the
        state of the system as it processes each step.
        Attributes:
            deferred (list[elements.Event]): A list to store events that are deferred during execution.
        Args:
            queue (Queue, optional): The queue to hold events that are to be processed. If not provided, an
                asyncio.Queue is created by default.
            log (Logger, optional): The logger to output debugging information during execution. If not
                provided, a default logger is created using the model's fully qualified name.
        Methods:
            step: Processes a single step in the event-processing loop, handling execution
                of events, managing the deferred events, and setting the results for completed tasks.
            exec_behavior: Asynchronously executes the behavior associated with a given event,
                returning its result.
            exec_event_processing: An abstract method to be implemented by subclasses for the actual
                event processing logic per given event. It should return an InterpreterStep enum value
                representing the state of the event processing (e.g., deferred, complete).
    """
    deferred: list[elements.Event] = None

    def __init__(self, queue: Queue = None, log: Logger = None):
        """
            Initialize a new instance of the class.
            This constructor initializes the instance by taking an optional queue and log parameters. If the queue or log are not provided, it initializes a new asyncio.Queue and creates a new logger based on the qualified name of the class instance, respectively.
            Args:
                queue (Optional[Queue]): An asyncio Queue instance for managing async tasks. If None, a new asyncio.Queue is created.
                log (Optional[Logger]): A Logger instance for logging messages. If None, a logger is created using the qualified name of the class.
            Attributes:
                deferred (list): A list that is initialized to an empty list and is intended to store deferred tasks or callbacks.
        """
        super().__init__(
            queue=queue or asyncio.Queue(),
            log=log or create_logger(model.qualified_name_of(self)),
        )
        self.deferred = []

    async def step(self):
        """
            Asynchronously processes the events in the event queue, handling each event accordingly.
            This coroutine walks through the events in the event queue, processes each,
            and handles deferred and completed events. It ensures that each event is processed
            exactly once per iteration, either by immediately processing it or deferring it for
            later. Once an event is processed, any resulting effects are immediately resolved,
            potentially affecting the state of future events or the queue itself. This method also
            handles the cleanup of completed events and prepares the queue state for the next
            iteration.
            Processed events are removed from the event queue. If an event is deferred, it's
            added to a deferred list to be processed in the next iteration. The events are
            processed in an order that respects dependencies between them, ensuring correct
            behavior of the state machine.
            If all events are processed without new ones being added, the coroutine exits.
            Otherwise, it continues to run until there are no more events to process or all
            remaining events have been deferred.
            This function will also update the internal deferred events list for future processing.
            Returns:
                None
        """
        processed = []
        events = []
        deferred = self.deferred
        stack = []

        while events := list(
            dict.fromkeys(
                (
                    # include active events in the event pool
                    *(event for event in self.model.pool if event in self.stack),
                    # include deferred events from the previous iteration
                    *deferred,
                    # include events from the previous iteration
                    *events,
                    # include events from the queue
                    *(self.queue.get_nowait() for _ in range(self.queue.qsize())),
                )
            )
        ):
            # reset deferred events
            deferred = []
            # if all events have been processed this iteration is complete
            if not all(event in processed for event in events):
                # clear the idle flag to prevent interruptions
                while events:
                    # pop the first event from the list
                    event = events.pop(0)
                    results = await self.exec_event_processing(event)
                    self.log.debug(
                        f"Processed {model.qualified_name_of(event)} results {results} and {processed}"
                    )
                    # add the event to the list of processed events
                    if results is InterpreterStep.deferred:
                        deferred.append(event)
                    else:
                        if model.owner_of(event) is None:
                            stack.append((self.pop(event), results))
                        if results is InterpreterStep.complete:
                            processed = []
                            break
                    processed.append(event)
                continue
            break
        self.deferred = deferred
        for future, results in stack:
            future.set_result(results)

    async def exec_behavior(
        self, behavior: elements.Behavior, event: typing.Optional[elements.Event]
    ):
        """
        Execute a specified behavior with an optional event.
        This coroutine executes the given `behavior`, logging its execution. It handles
        both synchronous and asynchronous activities. If the behavior's activity is a
        coroutine or a future, it will await it before returning the result.
        Args:
            behavior (elements.Behavior): The behavior to execute.
            event (typing.Optional[elements.Event]): The event to pass to the behavior's activity, if any.
                Defaults to None.
        Returns:
            The result of the executed behavior's activity. The type of the result depends on the
            behavior implementation.
        """
        behavior_name = model.qualified_name_of(behavior)
        self.log.debug(f"Executing {behavior_name}")
        value = behavior.activity(event)
        if asyncio.isfuture(value) or asyncio.iscoroutine(value):
            value = await value
        return value

    async def exec_event_processing(self, event: elements.Event) -> InterpreterStep:
        """
            Asynchronously execute the processing of an event in the event-driven system.
            This function is responsible for taking an event object, processing it according to the system's
            rules and workflows, and producing an InterpreterStep, which indicates the state or action
            to be taken following the event's processing.
            Args:
                event (elements.Event): The event object to be processed. This should encapsulate
                    all the information necessary for the event's processing, such as type, payload,
                    and context.
            Returns:
                InterpreterStep: An instance representing the outcome of processing the event. This
                    could include state changes, actions to be executed, or further events to be triggered
                    as a result of the initial event's processing.
            Raises:
                Exception: If the event processing fails, an exception is raised indicating the failure condition.
        """
        pass
