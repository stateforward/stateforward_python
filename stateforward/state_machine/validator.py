"""

A module for validating state machines within the StateForward framework.

This module contains the `StateMachineValidator` class which provides methods to validate various components of a state machine. These components include final states, vertices, regions, transitions, and pseudostates. The validation process involves checking for conformity to the rules and structures defined within the state machine model.

Each method in the `StateMachineValidator` class corresponds to a specific type of state machine element and enforces constraints specific to that element's characteristics and expected behavior within a state machine context. The validation can trigger warnings for minor issues or raise exceptions for critical malformations or violations of the state machine semantics.

Attributes:
    logger: A logging.Logger object used for logging debug information or warnings during the validation process.

Classes:
    StateMachineValidator:
        A class responsible for validating the elements of a state machine. This includes methods to validate final states, vertices, regions, transitions, pseudostates, and completion events.

Methods:
    validate_final_state(self, final_state: elements.FinalState):
        Validates that a final state does not contain exit behaviors or outgoing transitions.

    validate_vertex(self, vertex: type[elements.Vertex]):
        Ensures that a vertex is contained within a region and has at least one incoming or outgoing transition.

    validate_region(self, region: type[elements.Region]):
        Confirms if a region has an initial state and correctly belongs to either a state machine or another state, but not both.

    validate_transition(self, transition: type[elements.Transition]):
        Verifies the correct construction of a transition, including the existence of a path, appropriate source and target elements, guards, and event triggers.

    validate_pseudostate(self, element: type[elements.Pseudostate]):
        Checks the constraints of a pseudostate based on its kind, such as choice, initial, or join, and verifies the validity of its incoming and outgoing transitions.

    validate_completion_event(self, event: type[elements.CompletionEvent]):
        Asserts that a completion event is owned by a state.

The `StateMachineValidator` operates on the premise that state machines are assembled and operate according to the principles and logic defined by the `stateforward.elements` module and the broader StateForward framework.

Note: Documentation automatically generated by https://undoc.ai
"""
from stateforward import model
from stateforward import elements
from stateforward.state_machine.log import create_logger
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from stateforward.elements import StateMachine

logger = create_logger("StateMachineValidator")


class StateMachineValidator(model.Validator):
    """
    A validator class that checks the integrity and consistency of a UML state machine model by performing various validation rules on its constituent parts.
        The StateMachineValidator class extends a generic model.Validator to provide specialized validation rules for UML state machine elements. It ensures that the state machine elements adhere to the UML specification and conform to the logical constraints necessary for a well-functioning state machine. It checks for a variety of conditions, such as the proper containment of vertices in regions, the correct usage of pseudostates, and the adherence of transitions to allowed configurations.
        Methods:
            validate_final_state(final_state: elements.FinalState):
                Validates that a final state does not have exit behavior or outgoing transitions.
            validate_vertex(vertex: type[elements.Vertex]):
                Validates that a vertex is contained within a region and has the required incoming or outgoing transitions.
            validate_region(region: type[elements.Region]):
                Checks if the region has an initial state if it is part of a state machine and ensures it is not owned by both a state and a state machine.
            validate_transition(transition: type[elements.Transition]):
                Validates various properties of a transition, including the existence of a path, appropriate guard and event configurations for join pseudostate targets, and internal transition characteristics.
            validate_pseudostate(element: type[elements.Pseudostate]):
                Enforces pseudostate constraints such as the lack of guards on choice pseudostate last transitions, outgoing transitions for initial pseudostates, and the unique origin regions for incoming transitions to a join pseudostate.
            validate_completion_event(event: type[elements.CompletionEvent]):
                Checks that a completion event is owned by a state.
    """
    def validate_final_state(self, final_state: elements.FinalState):
        """
            Validates if the provided final_state object is compliant with the constraints of a final state.
            Checks the final_state object to ensure it does not have an exit behavior or an outgoing transition, as neither
            are allowed for final states. If either of these attributes is present on the final_state object, an exception
            is raised with a message indicating the non-compliance.
            Args:
                final_state (elements.FinalState): The final state instance to be validated.
            Raises:
                Exception: If the final state has an exit behavior (indicated by the presence of an 'exit' attribute).
                Exception: If the final state has an outgoing transition (indicated by the presence of an 'outgoing' attribute).
        """
        if hasattr(final_state, "exit"):
            raise Exception(
                f"Final state {model.qualified_name_of(final_state)} cannot have exit behavior"
            )
        elif hasattr(final_state, "outgoing"):
            raise Exception(
                f"Final state {model.qualified_name_of(final_state)} cannot have do activity"
            )

    def validate_vertex(self, vertex: type[elements.Vertex]):
        """
        Validates that a vertex is properly contained within a region and has at least either an incoming or outgoing transition.
            This method ensures that the vertex provided as an argument adheres to the structural constraints of a state machine. The validation process checks whether the vertex is contained within a region. If the vertex is not contained within a region, or if the container is not a subtype of `elements.Region`, the method raises a ValueError to signal the issue. Additionally, the method emits a warning if the vertex has no incoming or outgoing transitions, which could indicate a potential issue in the state machine design.
            Args:
                vertex (type[elements.Vertex]): The vertex object to validate.
            Raises:
                ValueError: If the vertex is not contained within a region or if the container of the vertex is not a subtype of `elements.Region`.
        """
        if vertex.container is None or not model.element.is_subtype(
            vertex.container, elements.Region
        ):
            raise ValueError(
                f"Vertex {model.qualified_name_of(vertex)} must be contained in a Region"
            )
        if vertex.outgoing.length == 0 and vertex.incoming.length == 0:
            logger.warning(
                f"Vertex {model.qualified_name_of(vertex)} has no incoming or outgoing transitions"
            )

    def validate_region(self, region: type[elements.Region]):
        """
        Validates that the passed Region object adheres to particular constraints concerning its properties and relationships with other model elements.
                Specifically, this function checks if the Region is associated with a state machine, it requires an initial state. Furthermore, the
                function enforces that a Region cannot be simultaneously owned by a state and a state machine, which would violate the model's structural rules.
                Args:
                    region (type[elements.Region]): The Region instance to be validated.
                Raises:
                    Exception: If the Region is associated with a state machine but does not have an initial state.
                    ValueError: If the Region is owned simultaneously by a state and a state machine.
        """
        if region.state_machine is not None and region.initial is None:
            raise Exception(
                f"Region {model.qualified_name_of(region)} must have initial state"
            )
        elif region.state_machine is not None and region.state is not None:
            raise ValueError(
                f"Region {model.qualified_name_of(region)} cannot be owned by a state and a state machine"
            )

    def validate_transition(self, transition: type[elements.Transition]):
        """
        Validates that the provided transition object adheres to several constraints regarding its elements and structure.
        Args:
            transition (type[elements.Transition]): The transition object that needs validation.
        Raises:
            ValueError: If the transition does not meet the required validity criteria. This includes having no path, improper use of guards or events in join transitions, incorrect kind with respect to sources, and transitions from Pseudostates with non-None events.
        Details of the constraints checked are as follows:
        - The transition must have a path defined. If it's None, a ValueError is raised.
        - If the transition's target is a Pseudostate of kind 'join', it must not have a guard or any completion events attached; otherwise, a ValueError is raised.
        - If the transition is of kind 'internal', it must originate from a State, and its source and target must be the same; otherwise, a ValueError is raised.
        - Transitions originating from a Pseudostate should not have any event associated with it. If there's an event, a ValueError is raised.
        """
        if transition.path is None:
            raise ValueError(
                f"Transition {model.qualified_name_of(transition)} doesn't have a path"
            )
        elif (
            model.element.is_subtype(transition.target, elements.Pseudostate)
            and transition.target.kind is elements.PseudostateKind.join
            and (
                transition.guard is not None
                or not all(
                    model.element.is_subtype(event, elements.CompletionEvent)
                    for event in transition.events.elements()
                )
                is not None
            )
        ):
            print(transition.guard, list(transition.events.elements()))
            raise ValueError(
                f"Transition {model.qualified_name_of(transition)} to join {model.qualified_name_of(transition.target)} must not have a guard or events"
            )
        elif transition.kind is elements.TransitionKind.internal and not (
            model.element.is_subtype(transition.source, elements.State)
            or transition.source != transition.target
        ):
            raise ValueError(
                f"Transition {model.qualified_name_of(transition)} with kind internal must have a State as its source, and its source and target must be equal"
            )
        elif (
            model.element.is_subtype(transition.source, elements.Pseudostate)
            and transition.events is not None
        ):
            raise ValueError(
                f"Transition {model.qualified_name_of(transition)} from outgoing Pseudostate may not have a Event."
            )
        # elif transition.target is not None:
        #     source_container = transition.source.container
        #     target_container = transition.target.container
        #     if (
        #         source_container != target_container
        #         and source_container.state == target_container.state
        #     ):
        #         raise ValueError(
        #             f"Transition {model.qualified_name_of(transition)} cannot cross Regions of the same State"
        #         )

    def validate_pseudostate(self, element: type[elements.Pseudostate]):
        """
        Validates the constraints of a Pseudostate within a state machine model.
        This method checks the validity of a given Pseudostate based on its kind (type).
        Different rules apply depending on whether the Pseudostate is of kind choice,
        initial, or join. The method raises a ValueError with a descriptive message
        if any of the following conditions are met:
        - If the Pseudostate kind is choice and the last outgoing transition has a guard.
        - If the Pseudostate kind is initial and there are no outgoing transitions
          or if there are any incoming transitions.
        - If the Pseudostate kind is initial and the outgoing transition has a guard.
        - If the Pseudostate kind is join and any incoming transitions originate from
          the same Region.
        Args:
            element (type[elements.Pseudostate]): The Pseudostate instance to validate.
        Raises:
            ValueError: An error indicating the specific validation rule that the
                        Pseudostate instance has violated.
        """
        if element.kind == elements.PseudostateKind.choice:
            last_transition = tuple(element.outgoing)[-1]
            if last_transition.guard is not None:
                raise ValueError(
                    f"choice psuedostate {model.qualified_name_of(element)} has a guard on the last transition"
                )
        elif element.kind == elements.PseudostateKind.initial:
            if not element.outgoing.length:
                raise ValueError(
                    f"initial psuedostate {model.qualified_name_of(element)} has no outgoing transitions"
                )
            elif element.incoming.length:
                raise ValueError(
                    f"initial psuedostate {model.qualified_name_of(element)} has incoming transitions"
                )
            outgoing = element.outgoing[0]
            if outgoing.guard is not None:
                raise ValueError(
                    f"initial psuedostate {model.qualified_name_of(element)} has a guard on the outgoing transition"
                )
        elif element.kind == elements.PseudostateKind.join:
            containers = set()
            for transition in element.incoming.elements():
                if model.qualified_name_of(transition.source.container) in containers:
                    print(
                        model.qualified_name_of(transition.source.container), containers
                    )
                    raise ValueError(
                        f"All {tuple(model.qualified_name_of(t) for t in element.incoming.elements())} incoming a join elements.Vertex ({model.qualified_name_of(element)}) must originate in different Regions"
                    )
                containers.add(model.qualified_name_of(transition.source.container))

    def validate_completion_event(self, event: type[elements.CompletionEvent]):
        """
        Validates that a given CompletionEvent is owned by a State.
        This method checks if the provided CompletionEvent instance is correctly
        owned by a State instance as per the modeling requirement. If the event is
        not owned by a State, the method raises a ValueError with an appropriate error
        message.
        Args:
            event (type[elements.CompletionEvent]): The CompletionEvent instance to be validated.
        Raises:
            ValueError: If the event is not owned by a State.
        """
        logger.debug("validating completion event")
        if not model.element.is_subtype(model.owner_of(event), elements.State):
            raise ValueError(
                f"CompletionEvent {model.qualified_name_of(event)} must be owned by a State"
            )
