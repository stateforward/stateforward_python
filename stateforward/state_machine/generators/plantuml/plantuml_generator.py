"""

A module for generating PlantUML diagrams from state machine models.

This module contains classes and functions that allow a user to create UML diagrams
in the PlantUML language by traversing through state machine models. It uses the
`Visitor` design pattern to visit different elements of the state machine and
converts them to a corresponding PlantUML representation.

Classes:
    PlantUMLStyle:
        A class used to configure the visual style of the generated UML diagram.
        It currently acts as a placeholder without any implementation details.

    PlantUMLGenerator(model.Visitor):
        A class that extends the `Visitor` pattern for generating PlantUML diagrams.
        It creates a textual representation of a given state machine model that can
        be rendered by PlantUML.

        Attributes:
            direction (str): The direction of the diagram layout (e.g., 'LR' for
                left to right).
            background_color (str): The color used for the diagram's background.
            cursor (Cursor): An instance of `Cursor` used to build the PlantUML text
                as elements are visited.

        Methods:
            __init__(self, direction, background_color):
                Initializes a new instance of the PlantUML generator.

            visit_*(self, element, cursor):
                Methods with names following the pattern 'visit_*' are overridden
                visiting methods for visiting specific state machine elements.
                Each visiting method takes an element and a cursor and processes the
                element, appending the appropriate PlantUML syntax to the cursor.

            qualified_name(self, element):
                Generates a qualified name for a given state machine element that is
                compatible with PlantUML's naming requirements.

            generate(self, model):
                Initiates the traversal of a state machine model and generates the
                PlantUML diagram. It returns the diagram as a string of PlantUML code.

Functions:
    create_logger(name):
        Creates and configures a logger for the PlantUML generator module.

Type Aliases:
    T:
        A generic type variable used for type hinting within the module.

Note: Documentation automatically generated by https://undoc.ai
"""
from stateforward import model
from stateforward import elements
from stateforward.state_machine.log import create_logger
from typing import Type, TypeVar
import inspect
from stateforward.state_machine.generators.cursor import Cursor

T = TypeVar("T")

logger = create_logger("plantuml")


class PlantUMLStyle:
    """
        A class representing the styling applied to diagrams generated in PlantUML.
        The PlantUMLStyle class encapsulates various style parameters such as color
        schemes, line styles, font settings, and other visual aspects that can be
        applied to create a consistent look and feel for PlantUML diagrams.
        Attributes:
            None defined.
        Methods:
            The class currently does not define any methods.
        Note:
            This class is a placeholder and does not currently implement any functionality.
            It may be extended in the future to include methods for handling style presets,
            or for applying styles to PlantUML elements.
    """
    pass


class PlantUMLGenerator(model.Visitor):
    """
    A visitor class that generates PlantUML diagrams from given state machine models.
        This class walks through a state machine model and produces text in PlantUML format that
        describes the layout and transitions of the state machine. The resulting PlantUML text
        can be used to create visual diagrams of the state machine's structure. The generator
        formats the output to be visually consistent with a predefined style, using orthographic
        lines, a specific color scheme for arrows, background, activity bars, states, borders,
        and text.
        Attributes:
            direction (str): A string indicating the direction in which state transitions should
                             be laid out in the resulting diagram. Defaults to 'LR' (left to right).
            background_color (str): A hexadecimal string that represents the background color
                                    for the diagram. Defaults to '#000000' (black).
        The class contains multiple 'visit_' methods, each responsible for handling different
        elements of the state machine, such as `visit_state_machine`, `visit_composite_state`,
        `visit_region`, `visit_state`, `visit_vertex`, `visit_constraint`, `visit_transition`,
        and `visit_pseudostate`. Each 'visit_' method processes its respective element and
        appends the generated PlantUML code to the cursor's content.
        The `generate` method initiates the generation process, and upon completion, returns
        the resulting PlantUML diagram as a string.
    """
    def __init__(self, direction: str = "LR", background_color: str = "#000000"):
        """
        Initializes a new instance of the class.
                This constructor initializes a new instance with a specified direction
                and background color for the diagram that it will operate on. It sets up
                default styling parameters for the diagram, including line type, arrow
                color, background color, bar color, font style, and state style. It also
                instantiates a new `Cursor` object with a starting UML definition that
                is pre-formatted with these styles.
                Args:
                    direction (str, optional): The direction of layout for the diagram.
                        Default to 'LR' which stands for left-to-right.
                    background_color (str, optional): The hexadecimal color value for the
                        diagram's background. Defaults to '#000000' which is black.
        """
        super().__init__()
        self.cursor = Cursor(
            """@startuml
skinparam linetype ortho
skinparam arrowColor white
skinparam backgroundColor #000000
skinparam ActivityBarColor white
<style>
circle {
    backgroundColor white
}
</style>
skinparam State {
    backgroundColor black
    FontColor white
    borderColor white
}
"""
        )
        self.direction = direction

    def visit_state_machine(
        self, state_machine: Type["elements.StateMachine"], cursor: Cursor
    ):
        """
            Visits a StateMachine object, processes its components and constructs its corresponding representation.
            This method traverses a state machine, starting with the given state_machine instance. It then iteratively visits and processes
            all the owned elements of the state machine, such as states and transitions. As it visits each element, it generates and appends the
            appropriate representation to the given cursor. This representation includes the name and qualified name of states, as well as the
            transitions between states, along with their associated events if any.
            Args:
                state_machine (Type['elements.StateMachine']): The StateMachine object to visit.
                cursor (Cursor): The Cursor object where the resulting string representation of the state machine is appended to.
            Returns:
                bool: Always returns True, indicating successful visitation.
        """
        cursor.append(
            f'state "{model.name_of(state_machine)}" as {self.qualified_name(state_machine)} {{\n',
        )
        self.visit_composite_state(state_machine, cursor=cursor)
        for element in model.all_owned_elements_of(state_machine):
            if model.element.is_subtype(
                element, elements.Transition
            ) and not model.element.is_subtype(element.source, elements.Pseudostate):
                events = ""
                if element.events:
                    events = "|".join(event.name for event in element.events.elements())
                cursor.append(
                    f"{self.qualified_name(element.source)} --> {self.qualified_name(element.target)}: {events}\n"
                )
        return True

    def visit_composite_state(
        self,
        composite_state: Type["elements.CompositeState"],
        cursor: Cursor = None,
    ):
        """
            Visits a composite state in the context of a state machine and appends the necessary formatting to a cursor.
            This function is responsible for handling the traversal and formatting of a composite state,
            which may contain one or more regions, and adds the formatted structure to the provided cursor.
            It also handles the inclusion of the composite state's documentation as a note, if available.
            Args:
                composite_state: The `CompositeState` object representing the composite state in the state machine.
                cursor: An optional `Cursor` instance where the formatted output will be appended. If not provided,
                        a new instance will be created internally.
            Returns:
                bool: Always returns True to indicate successful visitation of the composite state.
        """
        region = composite_state.region
        with cursor.auto_indent(indent=2) as _cursor:
            regions = tuple(region.elements())
            if regions:
                for index, region in enumerate(region.elements()):
                    self.visit_region(region, _cursor)
        cursor.append("}\n")
        docs = composite_state.__doc__
        if docs is not None:
            cursor.append(
                f"note top of {self.qualified_name(composite_state)}: \"{docs.lstrip().encode('unicode_escape').decode()}\""
            )
        return True

    def qualified_name(self, element: Type[model.Element]):
        """
        Generates a modified qualified name for the given element where periods are replaced with underscores.
        Args:
            element (Type[model.Element]): The element for which to generate the qualified name.
        Returns:
            str: A string representing the qualified name of the element with periods replaced by underscores.
        """
        return element.qualified_name.replace(".", "_")

    def visit_region(self, region: Type["elements.Region"], cursor: Cursor):
        """
        Visits a region and processes its vertices, adding PlantUML state definition and transitions for statecharts.
        Given a `Region` object, this function will examine it to determine whether a new state definition needs to be created, handling subvertices as necessary. If the `Region`'s name does not start with 'region_', a new state definition is started and subvertices are given their own block within the state definition. Otherwise, subvertices are processed directly within the current scope.
        This function iterates over the subvertices of the given `Region`. For each subvertex, it delegates processing to the `visit_vertex` method by passing the vertex and the current cursor for documentation construction.
        The function appends a special entry state arrow notation '[*] --> StateName' if the region has subvertices, followed by the state definition and subvertex details.
        Args:
            region (Type['elements.Region']): The region to visit and process for PlantUML documentation.
            cursor (Cursor): A `Cursor` object to maintain the current position in the documentation structure and to which the state definition will be appended.
        Returns:
            bool: Always returns `True` to signal successful processing of the region.
        """
        if region.subvertex.length:
            if not region.name.startswith("region_"):
                cursor.extend(
                    f"[*] --> {self.qualified_name(region)}\n",
                    f'state "{region.name}" as {self.qualified_name(region)} {{\n',
                )
                with cursor.auto_indent() as _cursor:
                    for index, vertex in enumerate(region.subvertex.elements()):
                        self.visit_vertex(vertex, _cursor)
                cursor.append("}\n")
            else:
                for index, vertex in enumerate(region.subvertex.elements()):
                    self.visit_vertex(vertex, cursor)

        return True

    def visit_state(self, state: type["elements.State"], cursor: Cursor):
        """
        Extends the current object with the given items.
            This method allows for adding multiple items to the current object by unpacking
            a variable number of arguments, each of which can be either a string or an instance
            of 'Cursor'. The method uses polymorphism, calling the 'extend' method of a superclass
            to handle the actual operation.
            Args:
                *items (Union[str, 'Cursor']): A variable number of arguments which can either be
                    strings or 'Cursor' instances.
        """
        name = (
            state.name
            if not state.submachine
            else f"{state.name}<{state.submachine.name}>"
        )
        cursor.append(
            f'state "{name}" as {self.qualified_name(state)} {{\n',
        )
        return self.visit_composite_state(state, cursor=cursor)

    def visit_vertex(self, vertex: Type["elements.Vertex"], cursor: Cursor):
        """
        Visits a given vertex during a cursor traversal in a graph or state machine model.
        This method determines the type of vertex being visited and delegates to the appropriate handling method. If the vertex is identified as a kind of pseudostate, it is handed off to the `visit_pseudostate` method. Otherwise, it is processed by the `visit_state` method.
        Args:
            vertex (Type['elements.Vertex']): The vertex object that needs to be visited. Must be an instance or subclass of 'elements.Vertex'.
            cursor (Cursor): The cursor object representing the current position in the traversal or the entity used to navigate the model.
        Returns:
            The result of the delegated `visit_pseudostate` or `visit_state` method, depending on the type of the vertex.
        """
        if model.model.is_subtype(vertex, elements.Pseudostate):
            return self.visit_pseudostate(vertex, cursor)
        return self.visit_state(vertex, cursor)

    def visit_constraint(self, constraint: Type["elements.Constraint"], cursor: Cursor):
        """
            Visit and process a constraint during tree traversal.
            This method is responsible for visiting a constraint and appends its documented
            condition or name to the provided cursor. If the constraint condition has a
            docstring, it uses the docstring, otherwise, it uses the condition's
            function name.
            Args:
                constraint (Type['elements.Constraint']): The constraint element to visit.
                cursor (Cursor): The cursor to which the constraint information will be appended.
            Returns:
                bool: Always returns True to indicate successful processing of the constraint.
        """
        doc = inspect.getdoc(constraint.condition)
        cursor.append(f": [{doc or constraint.condition.__name__}]")
        return True

    def visit_transition(self, transition: Type["elements.Transition"], cursor: Cursor):
        """
        Visits a transition element within a state machine or process flow.
        This method appends a formatted string representation of the transition to the given cursor. The string includes the source and target states of the transition, connected by an arrow. If the transition has associated events, their names are concatenated, separated by the pipe character, and added to the cursor. If the transition has a guard (a constraint), the `visit_constraint` method is called with the guard and cursor as arguments. The method concludes by appending a newline character to the cursor and returning True to indicate successful visitation.
        Args:
            transition (Type['elements.Transition']): The transition element to visit.
            cursor (Cursor): The cursor to which the transition representation is appended.
        Returns:
            bool: Always returns True to indicate the transition was successfully visited.
        """
        cursor.append(
            f"{self.qualified_name(transition.source)} --> {self.qualified_name(transition.target)}"
        )
        if transition.events:
            cursor.extend(
                "|".join(event.name for event in transition.events.elements())
            )
        if transition.guard:
            self.visit_constraint(transition.guard, cursor)
        cursor.append("\n")
        return True

    def visit_pseudostate(
        self, pseudostate: Type["elements.Pseudostate"], cursor: Cursor
    ):
        """
            Visit the given pseudostate and use its kind to determine the correct notation.
            This method is responsible for appending specific notations to the 'cursor'
            depending on the kind of pseudostate encountered. Notations are appended as
            strings depicting UML representations of pseudostates such as initial, choice, fork,
            entry point, exit point, and join.
            Args:
                pseudostate (Type['elements.Pseudostate']): The pseudostate to visit.
                cursor (Cursor): The cursor object where notations will be appended as the pseudostate is processed.
            Returns:
                bool: Always returns True as an indication of successful execution.
        """
        if pseudostate.kind is elements.PseudostateKind.initial:
            transition = tuple(pseudostate.outgoing.elements())[0]
            cursor.append(f"[*] --> {self.qualified_name(transition.target)}\n")
        elif pseudostate.kind is elements.PseudostateKind.choice:
            cursor.append(
                f'state "{pseudostate.name}" as  {self.qualified_name(pseudostate)} <<choice>>\n'
            )
            for transition in pseudostate.outgoing.elements():
                self.visit_transition(transition, cursor)
        elif pseudostate.kind is elements.PseudostateKind.fork:
            cursor.append(
                f'state "{pseudostate.name}" as  {self.qualified_name(pseudostate)} <<fork>>\n'
            )
            for transition in pseudostate.outgoing.elements():
                self.visit_transition(transition, cursor)
        elif pseudostate.kind is elements.PseudostateKind.entry_point:
            cursor.append(
                f'state "{pseudostate.name}" as  {self.qualified_name(pseudostate)} <<entryPoint>>\n'
            )
            for transition in pseudostate.outgoing.elements():
                self.visit_transition(transition, cursor)
        elif pseudostate.kind is elements.PseudostateKind.exit_point:
            cursor.append(
                f'state "{pseudostate.name}" as  {self.qualified_name(pseudostate)} <<exitPoint>>\n'
            )

        elif pseudostate.kind is elements.PseudostateKind.join:
            cursor.append(
                f'state "{pseudostate.name}" as  {self.qualified_name(pseudostate)} <<join>>\n'
            )
            self.visit_transition(tuple(pseudostate.outgoing.elements())[0], cursor)
        return True

    def generate(self, model: type[model.Model]) -> str:
        """
            Generates a UML diagram representation for the given model class.
            This function traverses the elements of the provided model class, using a cursor
            to append the UML representation to an internal string builder. After visiting
            all the elements and constructing the diagram, it appends an end tag (@enduml)
            to mark the termination of the UML diagram. It then converts the internal 
            representation to a string and prints it to the console. Finally, the string
            representation of the UML diagram is returned.
            Args:
                model (type[model.Model]): The model class for which to generate the UML diagram.
            Returns:
                str: A string representation of the UML diagram for the provided model class.
        """
        self.visit_element(model, self.cursor)
        self.cursor.append("@enduml\n")
        print(str(self.cursor))
        return str(self.cursor)
