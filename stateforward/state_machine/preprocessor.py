"""

This module contains functions and a class for preprocessing elements of a state machine model. The preprocessing primarily involves ensuring that the elements are complete, correctly related, and prepared for interpretation by an interpreter. The primary class in this module, `StateMachinePreprocessor`, provides methods for preprocessing various types of state machine elements such as states, composite states, regions, transitions, and events. Additionally, it contains methods to handle behavioral logic during state transitions and event handling. The preprocessor is responsible for manipulating the model elements, setting attributes, defining behavior, and constructing the necessary components of for a state machine execution to take place.

This module also defines several utility functions that support the preprocessing operations, including `no_async_activity`, `no_activity`, and `least_common_ancestor`. These functions offer default implementations for certain behaviors and identify relationships between elements.

The preprocessing steps include assigning containers to elements, setting default behaviors, sorting events, and constructing transition paths. Exceptions may be raised if necessary conditions are not met during preprocessing, such as a transition not having a source state or a state machine lacking regions.


Note: Documentation automatically generated by https://undoc.ai
"""
import asyncio
from inspect import iscoroutinefunction
from asyncio import Queue as AsyncQueue
from stateforward import model
from stateforward import elements
from stateforward.state_machine.log import create_logger
from stateforward.protocols.logger import Logger


async def no_async_activity(self, event: "elements.Event"):
    """
    Async function placeholder for handling a non-async activity event.
    This function is designed to run asynchronously, but it doesn't perform any asynchronous
    operations. It acts as a placeholder or a stub that might be overridden or
    implemented in a subclass.
    Args:
        event (elements.Event): The event object that triggers the no_async_activity.
    Returns:
        None: This function does not return any value.
    Raises:
        NotImplementedError: If the function has not been implemented.
    """
    pass


def no_activity(self, event: "elements.Event"):
    """
    Handles the scenario where no activity is detected for a given event.
    This method may be intended to handle cleanup, state reset, notifications, or other
    related tasks when an event has not been followed by activity within a specified timeframe.
    Args:
        event (elements.Event): The event instance for which no activity was detected.
    Returns:
        None.
    Note:
        The actual implementation should provide specifics on what constitutes 'no activity'
        and what actions are performed when this method is called.
    """
    pass


def least_common_ancestor(
    node1: type["elements.Vertex"], node2: type["elements.Vertex"]
):
    """
    Finds the least common ancestor (LCA) in a state machine for two given vertices.
        Given two vertices within a state machine, this function will traverse the hierarchy to find the closest
        common container that encapsulates both vertices. The least common ancestor is a concept in graph theory
        used to determine the lowest shared node in a tree or hierarchical structure where two nodes are present.
        Args:
            node1 (type['elements.Vertex']): The first vertex in the state machine.
            node2 (type['elements.Vertex']): The second vertex in the state machine.
        Returns:
            The least common ancestor container that encapsulates both node1 and node2.
            If no common ancestor exists, or if one of the nodes is not part of a valid hierarchy,
            the function may return None or the container directly above the node which has no state.
        Raises:
            May raise an exception if the state machine structure is invalid or if nodes are not properly
            contained within the machine's hierarchy.
        Note:
            This function assumes that 'model.is_descendant_of' is a method able to determine if one vertex is
            a descendant of another, and 'container.state' should be a property that refers to the state that
            contains the container. The specific exception raised on invalid structures is not detailed here and
            depends on the implementation of the state machine model.
    """
    if model.is_descendant_of(node1.container, node2):
        lca = node1.container
    elif model.is_descendant_of(node2.container, node1):
        lca = node2.container
    else:
        container = node1.container
        if container.state is None:
            return container
        lca = least_common_ancestor(container.state, node2)
    return lca


class StateMachinePreprocessor(model.Preprocessor):
    """
    A preprocessor for state machines that ensures the proper arrangement and configuration of states, regions, transitions, and other related elements within a behavior model.
    Attributes:
        log (Logger): A logging instance for recording debug, informational, warning, and error messages.
    Methods:
        preprocess_vertex(self, element):
            Ensures that every vertex (state) is correctly placed within its container (region) and that incoming/outgoing transitions are properly assigned.
        preprocess_state(self, element):
            Prepares a state for processing, including the registration of composite states or submachines, and the association of entry, exit, and activity behaviors.
        preprocess_composite_state(self, element):
            Manages composite state elements and their child elements by ensuring correct ownership and containment relationships.
        create_transition_path(self, transition):
            Generates and assigns a path for the provided transition, detailing the states to enter and leave during the transition.
        preprocess_final_state(self, element):
            Configures a final state by ensuring it is recognized as a vertex and has the appropriate attributes set.
        preprocess_transition(self, element):
            Prepares transitions by setting their source, target, container, and path, including adjusting for various kinds of transitions like internal, local, and external.
        preprocess_region(self, element):
            Organizes the elements of a region by setting up its states ('subvertex'), initial state, state machine, and, if applicable, enclosing state.
        preprocess_processor(self, element):
            Configures the interpreter or processor based on the concurrency kind of the model.
        preprocess_call_event(self, element):
            Adapts call event execution to work properly within the asynchronous or synchronous execution context.
        preprocess_change_event(self, element):
            Sets up change events with appropriate synchronization primitives based on the model's concurrency.
        preprocess_behavior(self, element):
            Structures behaviors within the model and prepares the activity to match the model's concurrency requirements. Populates the 'pool' with events and sets the behavior's context.
        preprocess_state_machine(self, element):
            A specific preprocessing routine for state machines that initializes the composite state, behavior, and ensures proper event ordering within the pool.
    """

    log: Logger = create_logger("StateMachinePreprocessor")

    def preprocess_vertex(self, element: type["elements.Vertex"]):
        """
        Preprocess the given vertex instance by finding its container and associating incoming and outgoing transitions.
        The function looks for the container of the vertex by finding an ancestor of type Region. It throws an error log if
        the vertex has no container. It goes on to determine and set the 'container' attribute for the vertex. Furthermore,
        the function collects and sets the 'outgoing' transitions originating from the vertex and the 'incoming' transitions
        targeting the vertex. These transitions are found by searching among descendants of the element's model.
        Args:
            element (type['elements.Vertex']): An object of subtype Vertex which is to be preprocessed.
        Raises:
            Logs an error if the vertex does not have a container.
        """
        logger = create_logger(f"preprocess_vertex({model.qualified_name_of(element)})")
        logger.debug(f"finding container for {model.qualified_name_of(element)}")
        container = model.find_ancestor_of(
            element,
            lambda owned_element: model.element.is_subtype(
                owned_element, elements.Region
            ),
        )

        if container is None:
            logger.error(f"vertex {model.qualified_name_of(element)} has no container")
        logger.debug(f"found container {model.qualified_name_of(container)}")
        model.set_attribute(element, "container", container)

        outgoing = list(element.outgoing) if element.outgoing else []
        incoming = list(element.incoming) if element.incoming else []
        for transition in model.find_descendants_of(
            model.of(element),
            lambda owned_element: model.element.is_subtype(
                owned_element, elements.Transition
            ),
        ):
            if (
                transition.source or model.owner_of(transition)
            ) == element and transition not in outgoing:
                outgoing.append(transition)
            elif transition.target == element and transition not in incoming:
                incoming.append(transition)
        model.set_attribute(element, "outgoing", model.collection(*outgoing))
        model.set_attribute(element, "incoming", model.collection(*incoming))

    def preprocess_state(self, element: type["elements.State"]):
        """
        Preprocesses a given state within the state machine, handling the presence of submachines and
        establishing behaviors such as 'entry', 'exit', and 'activity' if they are not already defined.
        This function is intended to ensure that the state is properly preprocessed before being used within a
        state machine context. It checks whether the state is a composite state or a submachine state and
        performs preprocessing accordingly. For a composite state, `preprocess_composite_state` is called.
        If the state is a submachine state, a warning is logged. The function also guarantees that every
        state has 'entry', 'exit', and 'activity' behaviors by creating new elements with these roles if
        they do not exist.
        Args:
            element (type[elements.State]): The state element to preprocess. It is expected to be an
                instance of or a type derived from 'elements.State'.
        Raises:
            This function does not explicitly raise any exceptions, but indirectly raised exceptions may
            occur from the calls to `preprocess_composite_state`, `model.set_attribute`, and any other
            internal processing methods.
        """
        if element.submachine is None:
            self.preprocess_composite_state(element)
        else:
            self.log.warning(f"preprocessing submachine {element}")
            # for region in element.submachine.regions.elements():
            #     model.set_attribute(region, "state", element)
            #     model.set_attribute(region, "state_machine", None)

        self.preprocess_vertex(element)

        for behavior in ("entry", "exit", "activity"):
            if getattr(element, behavior) is None:
                model.set_attribute(
                    element,
                    behavior,
                    model.element.new(behavior, bases=(elements.Behavior,)),
                )

    def preprocess_composite_state(self, element: type["elements.CompositeState"]):
        """
        Preprocesses a composite state to organize its elements and regions appropriately.
        This function iterates over the owned elements of the given composite state element
        and classifies them into transitions, subvertices, and regions. It then manipulates
        the element's regions to ensure that subvertices and transitions are properly
        contained. If subvertices are present without a corresponding region, a new region is
        created and assigned. Transitions and subvertices are then moved to the appropriate
        region, and the element's structure is updated to reflect these changes.
        Args:
            element (type['elements.CompositeState']): The composite state element to preprocess.
        Raises:
            ValueError: If the precondition that the element must be a composite state
                        is not satisfied, though not explicitly checked in this function.
        """
        transitions = []
        subvertex = []
        regions = []
        for owned_element in [
            _owned_element
            for _owned_element in model.owned_elements_of(element)
            if not any(
                model.is_descendant_of(region, _owned_element) for region in regions
            )
        ]:
            if model.element.is_subtype(owned_element, elements.Transition):
                transitions.append(owned_element)
            elif model.element.is_type(owned_element, model.Collection) and all(
                model.element.is_subtype(_child, elements.Transition)
                for _child in owned_element
            ):
                transitions.extend(owned_element)
            elif model.element.is_subtype(owned_element, elements.Vertex):
                subvertex.append(owned_element)
            elif model.element.is_subtype(owned_element, elements.Region):
                regions.append(owned_element)
        if subvertex:
            new_region = model.element.new(
                f"region_{len(regions)}",
                bases=(elements.Region,),
            )
            model.set_attribute(
                element,
                "regions",
                model.collection(new_region, *regions),
            )
            for owned_element in subvertex + transitions:
                if (
                    owner_of_owned_element := model.owner_of(owned_element)
                ) is not None:
                    owned_element = model.remove_owned_element_from(
                        owner_of_owned_element, owned_element
                    )
                    model.set_attribute(owned_element, "container", new_region)
                if (
                    owned_element_name := model.name_of(owned_element)
                ) in model.attributes_of(element):
                    model.set_attribute(new_region, owned_element_name, owned_element)
                else:
                    model.add_owned_element_to(new_region, owned_element)
        elif regions:
            model.set_attribute(element, "regions", model.collection(*regions))

        # else:
        #     model.set_attribute(element, "region", model.collection())

    def create_transition_path(self, transition: type["elements.Transition"]):
        """
        def create_transition_path(self, transition: type['elements.Transition']) -> 'elements.TransitionPath':
            Creates a transition path object for the given transition by analyzing the
            transition kind and identifying the states that need to be entered and exited.
            The function uses the transition kind to determine the correct sequence
            of states to be entered and exited. It supports three kinds of transitions:
            external, local, and self. For an 'external' transition, it collects all
            the states that need to be exited up to the common ancestor, and all the
            states that need to be entered down to the target. For a 'local' transition,
            it collects all states from the source to the target that need to be
            entered. For a 'self' transition, it simply appends the source to the leave
            list and the target to the enter list. The result is a new 'TransitionPath'
            object with defined 'enter' and 'leave' sequences.
            The function also inserts the identified states in the correct order to
            ensure the proper behavior for the state machine.
            Args:
                transition (type['elements.Transition']): The transition for which the path
                    needs to be created.
            Returns:
                elements.TransitionPath: A new transition path object with 'enter' and 'leave'
                    sequences corresponding to the transition provided.
        """
        enter = []
        leave = []
        # TODO this can be reduced
        if transition.kind == elements.TransitionKind.external:
            leave.append(transition.source)
            for ancestor in model.ancestors_of(transition.source):
                if model.id_of(ancestor) == model.id_of(transition.container):
                    break
                if model.element.is_subtype(ancestor, elements.State):
                    leave.append(ancestor)
            for ancestor in model.ancestors_of(transition.target):
                if model.id_of(ancestor) == model.id_of(transition.container):
                    break
                if model.element.is_subtype(ancestor, elements.State):
                    enter.insert(0, ancestor)
            enter.append(transition.target)
        elif transition.kind == elements.TransitionKind.local:
            for ancestor in model.ancestors_of(transition.target):
                if model.id_of(ancestor) == model.id_of(transition.source):
                    break
                if model.element.is_subtype(ancestor, elements.State):
                    enter.append(ancestor)
            enter.append(transition.target)
        elif transition.kind == elements.TransitionKind.self:
            leave.append(transition.source)
            enter.append(transition.target)
        return model.element.new(
            "path",
            bases=(elements.TransitionPath,),
            enter=model.collection(*enter),
            leave=model.collection(*leave),
        )

    def preprocess_final_state(self, element: type["elements.FinalState"]):
        """
        Preprocess the final state of a state machine.
        This method serves as an additional preprocessing step specifically for
        elements representing a final state within a state machine. It ensures that
        the final state is prepared and processed correctly following any general
        rules or validation specific to final states. It relies on the
        `preprocess_vertex` method to perform common preprocessing tasks
        applicable to vertices in the state machine.
        Args:
            element (type[elements.FinalState]): The final state element to be
                preprocessed. It is expected to be a subtype of the
                `elements.FinalState` class.
        Raises:
            TypeError: If `element` is not an instance or a subclass of
                `elements.FinalState`.
        Note:
            This docstring follows the Google Python Style Guide. Specific
            implementation details such as error handling or private method calls
            within the function are not described as they are typically not included
            in public API documentation.
        """
        self.preprocess_vertex(element)

    def preprocess_transition(self, element: type["elements.Transition"]):
        """
        Preprocesses a given transition by ensuring its source, events, effect, and path attributes are properly established. It sets defaults, checks for correct types, and calculates the kind of the transition based on the relationship between the source and target states. Also, it computes the transition's container by finding the least common ancestor of the source and target states, if applicable. Raises a ValueError if the transition has no source and is not owned by a state or if no container can be found for the transition.
            Args:
                element (type['elements.Transition']): The transition element to preprocess.
            Raises:
                ValueError: If the transition does not have a source and is not owned by a state or the transition has no container.
        """
        if element.source is None:
            owner = model.owner_of(element)
            if model.element.is_subtype(owner, model.Collection):
                owner = model.owner_of(owner)
            if not model.element.is_subtype(owner, elements.Vertex):
                raise ValueError(
                    f"transition {model.qualified_name_of(element)} has no source and is not owned by a state"
                )
            # transition source always defaults to the parent
            model.set_attribute(element, "source", owner)

        # yield from self.wait_for_completion_of(element.source)
        self.preprocess_element(element.source)
        if element.events is None:
            if model.element.is_subtype(element.source, elements.State):
                completion = element.source.completion
                if completion is None:
                    completion = model.element.new(
                        "completion",
                        (elements.CompletionEvent,),
                    )
                    model.set_attribute(element.source, "completion", completion)

                model.set_attribute(
                    element,
                    "events",
                    model.collection(
                        completion,
                    ),
                )

        if element.effect is None:
            model.set_attribute(
                element,
                "effect",
                model.element.new(
                    "effect",
                    (elements.Behavior,),
                    activity=no_async_activity
                    if model.of(element).concurrency_kind
                    is elements.ConcurrencyKind.asynchronous
                    else no_activity,
                ),
            )
        container = element.source.container
        if element.source == element.target:
            element.kind = elements.TransitionKind.self
        elif element.target is None:
            element.kind = elements.TransitionKind.internal
        elif model.is_descendant_of(element.source, element.target):
            element.kind = elements.TransitionKind.local
        else:
            self.preprocess_element(element.target)
            element.kind = elements.TransitionKind.external
            container = least_common_ancestor(element.source, element.target)
        if container is None:
            raise ValueError(
                f"transition {model.qualified_name_of(element)} has no container"
            )
        model.set_attribute(element, "container", container)
        path = self.create_transition_path(element)
        model.set_attribute(element, "path", path)

    def preprocess_region(self, element: type["elements.Region"]):
        """
        Preprocesses the given region element to ensure proper structure and relationships.
        This function processes a Region object within a state machine context. It starts by setting the 'subvertex' attribute
        of the given region to a collection of Vertex instances that are owned by the region. It then finds or assigns
        the 'initial' state of the region: if no initial state is already set, it searches for and assigns an Initial
        vertex type as the initial state, otherwise it logs the current initial state.
        Subsequently, this method identifies and assigns the region's parent element by checking if the parent or
        the owner of the parent is either a StateMachine or a State object. Accordingly, it sets the 'state' or
        'state_machine' attribute to refer to the immediate State or StateMachine that owns the region.
        Args:
            element (type['elements.Region']): The region element to preprocess.
        Raises:
            TypeError: If 'element' is not an instance of 'elements.Region'.
        Notes:
            This function modifies the 'element' by setting the various attributes related to its structure within
            a state machine.
        """
        from stateforward.elements import StateMachine

        def initial_filter(vertex):
            """
            Determines whether a given vertex is a subtype of an initial element.
            This function checks if the specified vertex is a subtype of `elements.Initial`
            by using the `is_subtype` method on the `model.element`. The result indicates whether
            the vertex represents an initial node in a graph or behavioral model.
            Args:
                vertex: The vertex to be evaluated. This is expected to be an instance of a vertex
                        within a graph or behavioral model.
            Returns:
                bool: True if `vertex` is a subtype of `elements.Initial`, False otherwise.
            """
            return model.element.is_subtype(vertex, elements.Initial)

        model.set_attribute(
            element,
            "subvertex",
            model.collection(
                *model.find_owned_elements_of(
                    element,
                    lambda owned_element: model.element.is_subtype(
                        owned_element, elements.Vertex
                    ),
                )
            ),
        )
        initial = getattr(element, "initial", None)

        if initial is None:
            initial = model.find_owned_element_of(element, initial_filter)
            model.set_attribute(element, "initial", initial)
        else:
            self.log.debug(
                f"region {model.qualified_name_of(element)} has initial {model.qualified_name_of(initial)}"
            )
        parent = model.owner_of(element)
        if not model.element.is_subtype(parent, (StateMachine, elements.State)):
            parent = model.owner_of(parent)
        model.set_attribute(
            element,
            "state",
            parent if model.element.is_subtype(parent, elements.State) else None,
        )
        model.set_attribute(
            element,
            "state_machine",
            parent if model.element.is_subtype(parent, StateMachine) else None,
        )

    def preprocess_processor(self, element: type["model.Interpreter"]):
        """
        Preprocesses an interpreter within the model by modifying its attributes.
        This function examines the concurrency kind of the provided 'element', which is an
        Interpreter instance, and sets the 'queue' attribute of the element to an 'AsyncQueue'
        if the 'concurrency_kind' is asynchronous.
        Args:
            element (type['model.Interpreter']): The interpreter instance from the model module
                that needs to be preprocessed.
        Returns:
            None. The function modifies the 'element' in place.
        Raises:
            AttributeError: Raised if the 'concurrency_kind' attribute does not exist on
                'element'.
        """
        concurrency_kind = element.model.concurrency_kind
        if concurrency_kind == elements.ConcurrencyKind.asynchronous:
            model.set_attribute(element, "queue", AsyncQueue)

    def preprocess_call_event(self, element: type["elements.CallEvent"]):
        """
        Preprocesses a call event element within a behavioral model, by assigning an appropriate __call__ method to it.
        This method assigns a synchronous or asynchronous `__call__` method to the provided call event element, depending on whether the operation within the element is a coroutine function. If the operation is asynchronous, the `__call__` method defined will be an asynchronous method that awaits the operation and sends the completion to the model's interpreter. For synchronous operations, the `__call__` method will simply invoke the operation, store the result, and return it.
        Args:
            element (type[elements.CallEvent]): The call event element to preprocess.
        Raises:
            AttributeError: If setting the `__call__` method on the element fails.
        """
        if asyncio.iscoroutinefunction(element.operation):

            async def __call__(self, *args, **kwargs):
                """
                Performs an asynchronous operation defined by `self.operation`, sends an instance of the current class to the `self.model.interpreter`, and then returns the result of the asynchronous operation.
                    This function is intended to be used as a callable interface for a class designed to manage and execute asynchronous operations. The actual operation must be provided by the `self.operation` attribute of the instance, which is to be an asynchronous function. After the operation is completed, the function proceeds to send an instance of the current class to an interpreter, likely for processing the result or for notifying that an operation has been completed.
                    Args:
                        *args: Variable length argument list.
                        **kwargs: Arbitrary keyword arguments.
                    Returns:
                        The result of the asynchronous operation executed by `self.operation`.
                """
                value = await self.operation(*args, **kwargs)
                await self.model.interpreter.send(self.__class__())
                return value

        else:

            def __call__(self, *args, **kwargs):
                """
                Performs the operation bound to the instance and sets its result.
                This method enables the instance to be called like a function. When called,
                it executes the operation that is bound to it with the provided arguments and keyword
                arguments, stores the result, and then returns the value obtained.
                Args:
                    *args: Variable length argument list to be passed to the operation.
                    **kwargs: Arbitrary keyword arguments to be passed to the operation.
                Returns:
                    The result of the operation function after being called with the specified arguments.
                """
                value = self.operation(*args, **kwargs)
                self.results.set_result(value)
                return value

        setattr(element, "__call__", __call__)

    def preprocess_change_event(self, element: type[elements.ChangeEvent]):
        """
        Preprocesses a ChangeEvent and assigns an asyncio Condition object to its 'condition' attribute.
        Args:
            element (type[elements.ChangeEvent]): An instance or subclass of ChangeEvent which will be preprocessed by assigning
                an asyncio Condition object to its 'condition' attribute.
        Raises:
            AttributeError: If the 'condition' attribute does not exist in the given ChangeEvent instance or subclass.
        """
        element.condition = asyncio.Condition

    def preprocess_behavior(self, element: type["elements.Behavior"]):
        """
        Preprocesses the behavior element regarding activity handling and event collection.
        This function sets up the behavior element's `activity` based on its concurrency kind. If the
        behavior element does not have an associated activity and it is asynchronous, a placeholder activity is
        assigned. If it is not asynchronous, a different placeholder is used. When the concurrency kind is
        asynchronous and the preexisting activity is not a coroutine function, a wrapper function is defined and
        assigned as the new activity.
        The module and qualname of the activity are set to match the behavior element's context. The function then
        proceeds to preprocess any owned elements.
        Additionally, this function collects all the event types from the descendants of the behavior element,
        creating a 'pool' of events, and establishes the 'context' for the behavior by looking for the closest
        ancestor of the type 'Behavior'.
        The modified activity, event pool, and context are set as attributes of the behavior element.
        Args:
            element (type['elements.Behavior']): The behavior element to preprocess.
        """
        concurrency_kind = model.of(element).concurrency_kind
        activity = element.activity
        if activity is None:
            if concurrency_kind == elements.ConcurrencyKind.asynchronous:
                activity = no_async_activity
            else:
                activity = no_activity
        elif (
            concurrency_kind == elements.ConcurrencyKind.asynchronous
            and not iscoroutinefunction(element.activity)
        ):

            def activity(self, event: "elements.Event", _activity=element.activity):
                """
                Performs a synchronous activity based on the given event.
                This method delegates the execution of an activity to another function passed
                as an argument, allowing customization of the activity that should be performed.
                Args:
                    event (elements.Event): The event instance that will be processed during
                        the activity.
                    _activity (Callable[[Any, elements.Event], Any]): A function that represents
                        the actual activity to be performed. This function takes the same
                        arguments as this method (the object itself and an event instance).
                        By default, it is set to `element.activity`.
                Returns:
                    The return value of the called `_activity` function, which depends on
                    its implementation and the nature of the activity being performed.
                """
                return _activity(self, event)

        activity.__module__ = model.of(element).__module__
        activity.__qualname__ = f"{model.qualified_name_of(element)}.activity"
        model.set_attribute(element, "activity", activity)
        context = model.find_ancestor_of(
            element,
            lambda ancestor: model.element.is_subtype(ancestor, elements.Behavior),
        )
        self.preprocess_owned_elements(element)

        events = []
        for descendant in model.descendants_of(element):
            if model.element.is_subtype(descendant, elements.Event):
                events.append(descendant)
        model.set_attribute(element, "pool", model.collection(*events))
        model.set_attribute(
            element,
            "context",
            context,
        )

    def preprocess_state_machine(self, element: type["elements.Behavior"]):
        """
        Preprocesses the given state machine element to prepare it for further processing.
        This method is responsible for preprocessing a state machine element, which involves
        logging a debug message with the qualified name of the state machine, preprocessing
        composite states within the state machine, preprocessing the behaviors of the state
        machine, and sorting the elements' pool by prioritizing CompletionEvent elements.

        Args:
            element (type[elements.Behavior]): The state machine element to preprocess, which is
                expected to be an instance of elements.Behavior or its subtypes.
        """
        self.log.debug(
            f"preprocessing state machine {model.qualified_name_of(element)}"
        )
        self.preprocess_composite_state(element)
        self.preprocess_behavior(element)
        model.sort_collection(
            element.pool,
            lambda event: not model.element.is_subtype(event, elements.CompletionEvent),
        )
