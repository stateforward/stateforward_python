"""

A module containing high-level elements for building state-machine functionality using a declarative syntax.

Functions in this module allow the creation and composition of states, transitions, events, and constraints, which together make up the components of a state machine, specifically within the context of a forward-state modelling structure.

Each function within the module provides a mechanism to create or translate behaviors, constraints, and various types of events into state machine elements.

Functions:
    initial(target, [effect]) -> elements.Initial:
        Creates an `Initial` pseudo-state for a state-machine. Accepts a target state and an optional effect that is either a Behavior type or a callable.

    transition(event, [target], [source], [guard], [effect], [type], [name]) -> elements.Transition:
        Creates transit...lements.ChangeEvent:
        Creates a `ChangeEvent` element based on the provided conditional expression.

    join(target, [effect], [guard]) -> elements.Join:
        Creates a `Join` node which aggregates multiple incoming transitions.

    fork(*outgoing, [name]) -> elements.Fork:
        Creates a `Fork` node that splits the flow into multiple concurrent transitions.

    choice(*transitions, [name]) -> elements.Choice:
        Creates a `Choice` pseudo-state that allows for branching based on guards of outgoing transitions.

    simple_state(name, [entry], [exit], [activity]) -> elements.State:
        Defines a simple state with optional entry, exit, and ongoing activity behaviors.

    entry_point(*transitions, [name]) -> elements.EntryPoint:
        Defines an entry point pseudo-state for composite states.

    exit_point([name]) -> elements.ExitPoint:
        Defines an exit point pseudo-state for composite states.

Note: Documentation automatically generated by https://undoc.ai
"""
from typing import Callable, Union, Sequence, Type, Optional
from datetime import datetime, timedelta
from stateforward import model, elements
from uuid import uuid1


def initial(
    target: type[elements.Vertex],
    effect: Optional[
        Union[
            type[elements.Behavior], Callable[[elements.Behavior, elements.Event], None]
        ]
    ] = None,
) -> type[elements.Initial]:
    """
        Creates an 'initial' element that represents the starting point of a state machine or a composite state.
        This function is responsible for creating a new 'initial' element, which is a specific type of vertex that defines the
        default entry point into a region or state machine. Optionally, an effect can be associated with the 'initial' element,
        which is an action executed when the transition from the 'initial' vertex is triggered.
        When an plain function or non-Behavior type callable is passed as the effect parameter, this function will
        automatically wrap it in a new Behavior subclass.
        Args:
            target (type[elements.Vertex]): The state or vertex to transition to from the 'initial' element.
            effect (Optional[Union[type[elements.Behavior], Callable[[elements.Behavior, elements.Event], None]]]):
                An optional effect to be executed when transitioning from the initial state. It can be either a Behavior subclass
                or a callable that takes a Behavior instance and an Event as arguments. If a non-Behavior callable is provided,
                it will be automatically wrapped in a new Behavior subclass.
        Returns:
            type[elements.Initial]: An 'initial' element that represents the starting point with an optional associated effect.
        Raises:
            TypeError: If the effect provided is neither a subtype of elements.Behavior nor a callable.
    """
    element = model.element.new(f"initial", (elements.Initial,))
    if not model.element.is_subtype(effect, elements.Behavior):
        effect = model.element.new(
            f"effect", bases=(elements.Behavior,), activity=effect
        )
    model.set_attribute(
        element,
        "transition",
        transition(target=target, effect=effect),
    )
    return element


def transition(
    event: Optional[Union[type[elements.Event], Sequence[type[elements.Event]]]] = None,
    target: Optional[type[elements.Vertex]] = None,
    source: Union[Sequence[type[elements.Vertex]], type[elements.Vertex]] = None,
    guard: Optional[
        Union[
            Callable[[elements.Constraint, elements.Event], bool],
            type[elements.Constraint],
        ]
    ] = None,
    effect: Optional[
        Union[
            type[elements.Behavior], Callable[[elements.Behavior, elements.Event], None]
        ]
    ] = None,
    type: type[elements.Transition] = elements.Transition,
    name: str = None,
) -> Union[type[elements.Transition], Sequence[type[elements.Transition]]]:
    """
    Creates a transition object in the format of a state machine element.
    This function is designed to facilitate the creation of transition elements for state machine models. It supports creating transitions with specified events, source, and target states, along with optional guard conditions and effects.
    The function can handle individual source states, multiple source states, and even defining transitions without explicit source or target, but not both. It performs checks and can implicitly create constraint or behavior elements from callable arguments for the guard and effect parameters. It also supports automatic name generation for the created transition based on source and target but allows custom names.
    Args:
        event (Optional[Union[type[elements.Event], Sequence[type[elements.Event]]]]): The event or events triggering the transition. If multiple events are provided, they should be in a list or tuple.
        target (Optional[type[elements.Vertex]]): The state machine vertex that the transition leads to.
        source (Union[Sequence[type[elements.Vertex]], type[elements.Vertex]]): The state machine vertex or vertices from which the transition originates.
        guard (Optional[Union[Callable[[elements.Constraint, elements.Event], bool], type[elements.Constraint]]]): A callable representing the guard condition or a subclass of elements.Constraint that defines the condition for the transition to occur.
        effect (Optional[Union[type[elements.Behavior], Callable[[elements.Behavior, elements.Event], None]]]): A callable representing the effect action or a subclass of elements.Behavior to be executed when the transition occurs.
        type (type[elements.Transition]): The type of transition to create, which should be a subclass of elements.Transition.
        name (str, optional): A custom name for the transition. If not provided, a name is generated based on the source and target.
    Returns:
        Union[type[elements.Transition], Sequence[type[elements.Transition]]]: A new transition object or a sequence of new transition objects that represents the state change.
    Raises:
        ValueError: If both source and target are None, indicating an invalid transition.
    """
    if isinstance(source, (list, tuple)):
        return model.collection(
            *(transition(event, target, _source, guard, effect) for _source in source)
        )
    elif source is not None and target is not None:
        # source = model.association(source)
        # target = model.association(target)
        if name is None:
            name = f"transition_from_{model.name_of(source)}_to_{model.name_of(target)}"
    elif target:
        # target = model.association(target)
        if name is None:
            name = f"transition_to_{model.name_of(target)}"
    elif source:
        # source = model.association(source)
        if name is None:
            name = f"transition_from_{model.name_of(source)}"
    else:
        raise ValueError("source and target cannot both be None")
    if event is None:
        events = None
    else:
        events = (
            model.collection(*event)
            if isinstance(event, (list, tuple))
            else model.collection(event)
        )
    if guard is not None and not model.element.is_subtype(guard, elements.Constraint):
        guard = constraint(guard)
    if effect is not None and not model.element.is_subtype(effect, elements.Behavior):
        effect = behavior(effect)
    new_transition = model.element.new(
        name,
        (type,),
        events=events,
        target=target,  # don't take ownership of the target
        source=source,  # don't take ownership of the source
        guard=guard,
        effect=effect,
    )
    return new_transition


def constraint(
    decorated: Callable[[elements.Constraint, elements.Event], bool],
    type: type[elements.Constraint] = elements.Constraint,
) -> type[elements.Constraint]:
    """
        Creates a new constraint type with a specified validation condition.
        The function dynamically creates a new subclass of the provided type (defaulting to `elements.Constraint`)
        with a name based on the `decorated` function's name. The provided `decorated` function is used as a
        condition method for validating constraints.
        Args:
            decorated (Callable[[elements.Constraint, elements.Event], bool]):
                A function that defines the condition for the constraint. It takes an `elements.Constraint`
                instance and an `elements.Event` as arguments and returns a boolean indicating if the event
                satisfies the constraint condition.
            type (type[elements.Constraint], optional):
                The type or class from which the new constraint type will inherit. Defaults to `elements.Constraint`.
        Returns:
            type[elements.Constraint]:
                A new constraint type that uses the `decorated` function as its condition for validation.
    """
    return model.element.new(
        f"constraint_{getattr(decorated, '__name__', repr(decorated))}",
        (type,),
        condition=decorated,
    )


def behavior(
    decorated: Callable[[elements.Behavior, elements.Event], bool],
    name: Optional[str] = None,
    type: type[elements.Behavior] = elements.Behavior,
) -> type[elements.Constraint]:
    """
        Creates a new subclass of `elements.Behavior` with a specific activity function.
        The new subclass will have a name provided by the user or a default name derived from the decorated
        function's name. The activity function is an essential part of the behavior which defines its
        actions in response to events.
        Args:
            decorated (Callable[[elements.Behavior, elements.Event], bool]): The function that will be used as the activity function
                for the new behavior subclass. This function should take an instance of `elements.Behavior` and an
                `elements.Event` as inputs and return a boolean indicating the success/failure of the behavior.
            name (Optional[str], optional): The name to give the new behavior class. If not provided, a default name will be
                generated by prefixing 'behavior_' to the name of the decorated function or its string representation.
                Defaults to None.
            type (type[elements.Behavior]): The type of the parent class from which the new subclass will inherit.
                Defaults to `elements.Behavior`.
        Returns:
            type[elements.Constraint]: A new subclass of `elements.Behavior` that incorporates the provided activity function.
    """
    return model.element.new(
        name or f"behavior_{getattr(decorated, '__name__', repr(decorated))}",
        (type,),
        activity=decorated,
    )


def after(
    hours: float = 0.0,
    minutes: float = 0.0,
    seconds: float = 0.0,
    milliseconds: float = 0.0,
    microseconds=0.0,
    days=0.0,
    when: Callable[[elements.TimeEvent], bool] = None,
) -> type[elements.TimeEvent]:
    """
    def after(hours: float=0.0, minutes: float=0.0, seconds: float=0.0, milliseconds: float=0.0, microseconds=0.0, days=0.0, when: Callable[[elements.TimeEvent], bool]=None) -> type[elements.TimeEvent]:
    """
    if when is None:
        when = timedelta(
            hours=hours,
            minutes=minutes,
            seconds=seconds,
            milliseconds=milliseconds,
            microseconds=microseconds,
            days=days,
        )
        name = f"after<{when}>"
    else:
        name = f"after<{getattr(when, '__name__', repr(when))}>"
    return model.element.new(
        name,
        (elements.TimeEvent,),
        when=when,
    )


def event(name: str) -> type[elements.Event]:
    """
        Creates a new event element with the given name.
        This function generates a new event-type element within the `elements` module,
        utilizing the `Event` class found in that module. An instance of the new event is
        constructed with the provided `name`, and is then returned to the caller.
        Args:
            name (str): The name of the event to create.
        Returns:
            type[elements.Event]: A new event element class derived from `elements.Event`.
    """
    return model.element.new(name, (elements.Event,))


def at(
    iso_or_year,
    month,
    day,
    hour=0,
    minute=0,
    second=0,
    microsecond=0,
    tzinfo=None,
    when=None,
):
    """
    Wraps a datetime construction mechanism to create a 'at' element representing a specific time event.
    This factory function accepts multiple forms of datetime input, either as a string in ISO format or
    individual datetime components, to instantiate a TimeEvent element. The 'at' element encapsulates a
    point in time event within the model.
    Args:
        iso_or_year (Union[str, int]): If given as a string, it is parsed as an ISO formatted datetime.
                                    If provided as an int, it is treated as the year component of the datetime.
        month (int, optional): The month component of the datetime. Required if iso_or_year is an int.
        day (int, optional): The day component of the datetime. Required if iso_or_year is an int.
        hour (int, optional): The hour component of the datetime. Defaults to 0.
        minute (int, optional): The minute component of the datetime. Defaults to 0.
        second (int, optional): The second component of the datetime. Defaults to 0.
        microsecond (int, optional): The microsecond component of the datetime. Defaults to 0.
        tzinfo (timezone, optional): The timezone information for the datetime. Defaults to None.
        when (datetime, optional): A pre-constructed datetime object. If provided, other arguments are ignored.
    Returns:
        Type[elements.TimeEvent]: A newly constructed 'at' element representing the specified time event.
    """
    if when is None:
        if isinstance(iso_or_year, str):
            when = datetime.fromisoformat(iso_or_year)
        else:
            when = datetime(
                iso_or_year, month, day, hour, minute, second, microsecond, tzinfo
            )
    return model.element.new("at", (elements.TimeEvent,), when=when)


def when(expr: Callable[[model.element.Element], bool]) -> type[elements.ChangeEvent]:
    """
    def when(expr: Callable[[model.element.Element], bool]) -> type[elements.ChangeEvent]:
    """
    name = f"when<{getattr(expr, '__name__', repr(expr))}>"
    return model.element.new(name, (elements.ChangeEvent,), expr=expr)


def join(
    target: type[elements.Vertex],
    effect=None,
    guard=None,
) -> Type[elements.Join]:
    """
    Creates a new Join element and associates a transition to it.
        This function is responsible for instantiating a Join element, which is a type of vertex used in state
        machines to synchronize parallel flows. The function also creates a transition from the new Join
        element to a specified target vertex, optionally including an effect or a guard.
        Args:
            target (type[elements.Vertex]): The vertex that the transition will lead to.
            effect (Optional[Callable]): An optional callable representing the effect executed when the transition
                                      occurs.
            guard (Optional[Callable]): An optional callable representing a guard condition that must be true for
                                     the transition to occur.
        Returns:
            Type[elements.Join]: An instance of a Join element with an associated transition.
    """
    join_element = model.element.new("join", (elements.Join,))
    model.add_owned_element_to(
        join_element,
        transition(target=target, source=join_element, effect=effect, guard=guard),
    )
    return join_element


def fork(
    *outgoing: Sequence[type[elements.Transition]], name: str = None
) -> Type[elements.Fork]:
    """
    Creates a new Fork element with a specified name and outgoing transitions.
    Args:
        *outgoing (Sequence[type[elements.Transition]]): A variable number of Transition elements which the new Fork should lead to.
        name (str, optional): The name of the new Fork element. If not provided, a default name 'fork' is used.
    Returns:
        Type[elements.Fork]: A new Fork element object initialized with the given name and outgoing transitions.
    """
    return model.element.new(
        name or "fork", (elements.Fork,), outgoing=model.collection(*outgoing)
    )


def choice(
    *transitions: Sequence[type[elements.Transition]],
    name=None,
) -> type["elements.Choice"]:
    # for enumerate, transition in transitions:
    #     transiiton.name = f"choice_{enumerate}"
    """
    Creates a new Choice model element with specified transitions and an optional name.
    Args:
        *transitions (Sequence[type[elements.Transition]]): A variable number of Transition sequences to be associated with the Choice.
        name (Optional[str], optional): An optional name for the Choice element. If not provided, 'choice' is used as a default name.
    Returns:
        type['elements.Choice']: A new instance of the elements.Choice class with the provided transitions.
    """
    return model.element.new(
        name or "choice", (elements.Choice,), outgoing=model.collection(*transitions)
    )


def simple_state(
    name: str,
    entry: Union[
        type[elements.Behavior], Callable[[elements.Behavior, elements.Event], None]
    ] = None,
    exit: Union[
        type[elements.Behavior], Callable[[elements.Behavior, elements.Event], None]
    ] = None,
    activity: Union[
        type[elements.Behavior], Callable[[elements.Behavior, elements.Event], None]
    ] = None,
):
    """
    Creates a new `State` object that is a subclass of `elements.State` with specified `entry`, `exit`, and `activity` behaviors.
        This function is used to create a new state for a state machine model. The `entry`, `exit`, and `activity` parameters can
        be either subclasses of `elements.Behavior` or callables that will be automatically turned into `elements.Behavior` subclasses
        using the `behavior` function. The newly created `State` subclass can then be used in defining the behavior of a state machine.
        Args:
            name (str): The name of the new state.
            entry (Union[type[elements.Behavior], Callable[[elements.Behavior, elements.Event], None]], optional):
                The entry behavior of the state, which can be a `elements.Behavior` subclass or a callable that takes
                an `elements.Behavior` instance and an `elements.Event` instance as arguments. Defaults to None.
            exit (Union[type[elements.Behavior], Callable[[elements.Behavior, elements.Event], None]], optional):
                The exit behavior of the state, similar to the `entry` parameter. Defaults to None.
            activity (Union[type[elements.Behavior], Callable[[elements.Behavior, elements.Event], None]], optional):
                The activity behavior of the state, similar to the `entry` and `exit` parameters. Defaults to None.
        Returns:
            type[elements.Constraint]: The newly created `State` subclass which is a subclass of `elements.State`.
        Raises:
            TypeError: If `entry`, `exit`, or `activity` arguments are neither `elements.Behavior` subclasses nor callables.
    """
    if not model.element.is_subtype(entry, elements.Behavior):
        entry = behavior(entry)
    if not model.element.is_subtype(exit, elements.Behavior):
        exit = behavior(exit)
    if not model.element.is_subtype(activity, elements.Behavior):
        activity = behavior(activity)
    return model.element.new(
        name,
        (elements.State,),
        entry=entry,
        exit=exit,
        activity=activity,
    )


def entry_point(
    *transitions: Sequence[type[elements.Transition]],
    name: str = None,
) -> type[elements.State]:
    """
    Creates a new state designated as an entry point with specified transitions and an optional name.
    Args:
        *transitions (Sequence[type[elements.Transition]]): A variadic argument list of Transition objects representing the outgoing transitions from the entry point.
        name (str, optional): The name of the entry point. If not provided, 'entry_point' will be used as the default name.
    Returns:
        type[elements.State]: A new State object configured as an EntryPoint with the specified transitions.
    Raises:
        TypeError: If the transitions are not of the expected Transition type.
    """
    return model.element.new(
        name or "entry_point",
        (elements.EntryPoint,),
        outgoing=model.collection(*transitions),
    )


def exit_point(
    name: str = None,
) -> type[elements.State]:
    """
        Creates a new ExitPoint state element for a state machine model.
        This function is responsible for generating a state element of type ExitPoint, which is used to define
        an exit point in a state machine's structure. If a name is provided, it is used as the name for the
        new ExitPoint. Otherwise, a default name 'exit_point' is utilized. The created ExitPoint is then
        returned.
        Args:
            name (str, optional): The name to be given to the ExitPoint element. Defaults to None,
                in which case the default name 'exit_point' is used.
        Returns:
            type[elements.State]: An instance of the ExitPoint state element, which is a subclass
                of elements.State.
    """
    return model.element.new(
        name or "exit_point",
        (elements.ExitPoint,),
    )
