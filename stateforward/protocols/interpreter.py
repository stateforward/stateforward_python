"""

Module that provides an asynchronous interpreter for state machines.

This module contains the Interpreter class, which implements an asynchronous interpreter designed to work with state machines based on the model provided by the stateforward package. It is capable of sending events, starting execution, and managing the execution flow based on a provided clock and a queue for asynchronous task handling.

Classes:
    InterpreterStep(Enum): Enumeration to represent the state of the interpreter steps, including complete, incomplete, and deferred.

    Interpreter(Protocol[T]): An abstract base class (or protocol) that outlines the methods and attributes
    necessary for an asynchronous interpreter.

Attributes:
    queue (Queue): An asynchronous queue for event handling.
    clock (Clock): A clock instance to manage time-based operations.
    stack (dict[model.Element, Future]): A mapping of state machine elements to their futures, used to track their active status.
    log (logging.Logger): A logger instance to log interpreter events and actions.

Methods:
    __init__(self, queue: Queue, log: logging.Logger=None): Initializes the interpreter.

    send(self, event: model.Element) -> Future: Sends an event to the interpreter.

    start(self, loop: asyncio.AbstractEventLoop=None): Starts the interpreter's event loop, optionally with a provided event loop.

    wait(self, *tasks: typing.Union[asyncio.Task, asyncio.Future], name: str=None, return_when: str=asyncio.FIRST_COMPLETED) -> asyncio.Task: Waits for tasks to complete and returns a task that will be done when specified conditions are met.

    run(self) -> None: Asynchronously runs the interpreter until completion.

    step(self) -> None: Performs a single step in the interpretation process.

    is_active(self, *elements: model.Element) -> bool: Checks if the given elements are currently active in the interpreter.

    push(self, element: model.Element, future: typing.Union[Future, asyncio.Task]): Pushes an element and its associated future onto the stack.

    pop(self, element: model.Element, result: typing.Any): Pops an element and its result from the stack.

    terminate(self): Terminates the interpreter.

    model: T = None: The model variable is an instance of the generic type T, which is bound to the model.Model.

This interpreter is utilized in environments where asynchronous operation and state machine processing is required. It follows a protocol-oriented programming paradigm to allow flexibility in implementation.

Note: Documentation automatically generated by https://undoc.ai
"""
import typing
from stateforward import model
from enum import Enum
import asyncio
from stateforward.protocols.future import Future
from stateforward.protocols.clock import Clock
from stateforward.protocols.queue import Queue
import logging


T = typing.TypeVar("T", bound=model.Model)


class InterpreterStep(Enum):
    """
    An Enum representing the state of an interpreter step in a process.
        This Enum class defines the possible states an interpreter step might be in during the execution
        of a task or sequence of operations. The states defined include 'complete', 'incomplete',
        and 'deferred', each representing a distinct stage in the step lifecycle.
        Attributes:
            complete (str): Indicates that the interpreter step has been fully executed without any
                pending actions remaining.
            incomplete (str): Indicates that the interpreter step has not been fully executed and
                there are actions that remain to be completed.
            deferred (str): Indicates that the interpreter step has been postponed or delayed,
                and its execution will occur at a later point in time.
    """
    complete = "complete"
    incomplete = "incomplete"
    deferred = "deferred"


class Interpreter(typing.Protocol[T]):
    """
    A protocol defining the structure and behaviour of an Interpreter.
        An Interpreter is designed to manage and orchestrate asynchronous events and tasks, typically in a
        workflow or event-driven system.
        Attributes:
            queue (Queue): An instance of Queue to hold pending events for processing.
            clock (Clock): An clock system responsible for tracking time-related attributes.
            stack (dict[model.Element, Future]): A mapping that keeps track of the futures associated with elements
                being processed.
            log (logging.Logger): Logger instance for logging events and messages.
        Methods:
            __init__(self, queue: Queue, log: logging.Logger=None):
                Initializes a new Interpreter instance.
            send(self, event: model.Element) -> Future:
                Enqueues an event for processing and returns a Future that will be resolved once the event is handled.
            start(self, loop: asyncio.AbstractEventLoop=None):
                Starts the interpreter's event processing loop, optionally using a given asyncio event loop.
            wait(self, *tasks: typing.Union[asyncio.Task, asyncio.Future], name: str=None,
                 return_when: str=asyncio.FIRST_COMPLETED) -> asyncio.Task:
                Awaits the completion of given tasks or futures, returning when the specified condition is met.
            run(self) -> None:
                Asynchronously runs the interpreter's main loop, processing queued events and managing stack entries.
            step(self) -> None:
                An asynchronous method to be implemented by subclass, representing a single step in the processing loop.
            is_active(self, *elements: model.Element) -> bool:
                Checks if the provided elements are actively being processed within the interpreter.
            push(self, element: model.Element, future: typing.Union[Future, asyncio.Task]):
                Adds an element and its associated Future or Task to the stack for tracking.
            pop(self, element: model.Element, result: typing.Any):
                Removes an element from the stack and resolves its associated Future or Task with the given result.
            terminate(self):
                Ends the interpreter's operation, typically by stopping its processing loop and handling cleanup.
        Class Variables:
            model (T): A generic type placeholder representing the model that the Interpreter will work with.
    """
    queue: Queue
    clock: Clock
    stack: dict[model.Element, Future]
    log: logging.Logger

    def __init__(self, queue: Queue, log: logging.Logger = None):
        """
        Initializes a new instance of the class with a specified queue and an optional logger.
        Args:
            queue (Queue): The queue object to which this instance will be related.
            log (logging.Logger, optional): The logging.Logger object for logging messages. If not provided,
                logging will not be used.
        """
        ...

    def send(self, event: model.Element) -> Future:
        """
        Sends an event to a designated element.
        Args:
            event (model.Element): The event instance to be sent.
        Returns:
            Future: A Future object representing the asynchronous operation of sending the event.
        """
        ...

    def start(
        self,
        loop: asyncio.AbstractEventLoop = None,
    ):
        """
        Initializes the asynchronous event loop for the instance object if not provided and starts the operation of the instance.
        Args:
            loop (asyncio.AbstractEventLoop, optional): An optional event loop instance that the instance will use to run its asynchronous operations. If 'None' is provided, the method will retrieve or create a default event loop for the current context. Defaults to 'None'.
        Raises:
            Exception: Raises an exception if the initialization of the event loop fails or there are issues starting the instance operation.
        """
        ...

    def wait(
        self,
        *tasks: typing.Union[asyncio.Task, asyncio.Future],
        name: str = None,
        return_when: str = asyncio.FIRST_COMPLETED,
    ) -> asyncio.Task:
        """
        Waits for the completion of one or more asyncio Task or Future objects, with options to specify the condition for returning and to label the waiting operation with a name for easier identification.
        Args:
            *tasks (Union[asyncio.Task, asyncio.Future]): One or more Task or Future objects that this function will wait for.
            name (str, optional): An optional name given to this waiting operation for identification purposes. Defaults to None.
            return_when (str): A string that determines when the function returns. It can be one of the predefined asyncio constants: `asyncio.FIRST_COMPLETED`, `asyncio.FIRST_EXCEPTION`, or `asyncio.ALL_COMPLETED`. Defaults to `asyncio.FIRST_COMPLETED`.
        Returns:
            asyncio.Task: A coroutine that will complete when the conditions specified by `return_when` are met by the tasks being waited on.
        """
        ...

    async def run(self) -> None:
        """
                Runs the asynchronous task.
                This coroutine, when awaited, initiates the execution of the task defined within it.
                It's designed to be an entry point for the async functionality of the class it belongs to.
                Returns:
                    None: This function does not return any value.
        """
        ...

    async def step(self) -> None:
        """
        Async function that performs a single step of a given process.
            This method is intended to be called within an asynchronous context. It should contain the
            core logic that needs to be executed in each step of the process that it's a part of. As
            this is a template with no implementation details provided, the specific actions performed
            during the step should be added once the actual functionality is developed.
            Args:
                self: A reference to the instance of the class that this method is bound to.
            Returns:
                None
        """
        pass

    def is_active(self, *elements: model.Element) -> bool:
        """
        Checks if all the specified elements are active within a stack.
            This method evaluates the presence of each element provided in the elements
            argument within an instance's stack attribute. It returns True only if all
            elements are found in the stack, otherwise it returns False.
            Args:
                elements (model.Element): An unpacked tuple of elements to check for
                    activeness in the stack.
            Returns:
                bool: True if all elements are in the stack, False otherwise.
        """
        return all(element in self.stack for element in elements)

    def push(self, element: model.Element, future: typing.Union[Future, asyncio.Task]):
        """
        Pushes an element onto a future or an asyncio.Task.
            This function takes an element and a future or an asyncio.Task and adds the element to it. It
            is assumed that the future or task can accept an element being pushed onto it, though
            the specifics of how this is done depends on the implementation of the future or task.
            Args:
                element (model.Element): The element to push onto the future or task.
                future (typing.Union[Future, asyncio.Task]): The future or asyncio.Task onto which the element
                    will be pushed.
            Returns:
                None
        """
        ...

    def pop(self, element: model.Element, result: typing.Any):
        """
        Removes an element from a data structure and returns the result of the operation.
        Args:
            element (model.Element): The element to remove from the data structure.
            result (typing.Any): The variable where the result of the removal operation should be stored.
        Returns:
            None
        """
        ...

    def terminate(self):
        """
            Terminates the current object.
            This method will perform the necessary operations to cleanly shut down or terminate the
            resources associated with the current instance of the object. This might involve closing files,
            releasing memory, or other cleanup activities.
            Args:
                None
            Returns:
                None
        """
        ...

    model: T = None
