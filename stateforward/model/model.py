"""

A module for representing and manipulating state models within the stateforward framework.

This module provides the `Model` class, along with functions `of`, `dump`, and `all_instances` to interact with
models in various ways. It also manages an internal registry of all model instances.

Classes:
    Model(Element): A subclass of `Element` that represents a model in the stateforward system. It
    manages its own instances and interacts with preprocessors and validators.

Functions:
    of(element: ElementType) -> Optional[Union[type[Model], Model]]:
        Retrieve the model associated with a given element.

    all_instances() -> dict[str, Model]:
        Get a dictionary mapping identifiers to `Model` instances representing all model instances.

    dump(element, level=0, associated_name=None):
        Recursively print information about an element and its associated elements.

Attributes:
    __all_instances__: dict[str, 'Model']:
        A class-level dictionary that keeps track of all `Model` instances.

    preprocessor: ClassVar[type['Preprocessor']]:
        A class-level attribute that should be set to the `Preprocessor` subclass that this `Model`
        class uses.

    validator: ClassVar[type['Validator']]:
        A class-level attribute that should be set to the `Validator` subclass that this `Model`
        class uses.

    interpreter: 'Interpreter':
        An instance of `Interpreter` which can be used to process the model.

Typing:
    ElementType: A type alias defined in `stateforward.model.element` representing a valid element type.
    Preprocessor: An interface representing a preprocessor that should process the model subclasses.
    Validator: An interface representing a validator that should validate the model subclasses.
    Interpreter: An interface representing an interpreter for processing the model.

Note: Documentation automatically generated by https://undoc.ai
"""
import typing
from stateforward.model.element import (
    Element,
    ElementType,
    id_of,
    type_of,
    qualified_name_of,
    owned_elements_of,
    associations_of,
)

if typing.TYPE_CHECKING:
    from stateforward.model.preprocessor import Preprocessor
    from stateforward.protocols.interpreter import Interpreter
    from stateforward.model.validator import Validator

__all__ = (
    "Model",
    "of",
    "dump",
    "all_instances",
)


class Model(Element):
    """
    A base class for creating models that are elements in a system with preprocessing, validation, and interpretation routines.
        This base class provides a framework for subclasses to define preprocessor and validator class variables that
        are meant to preprocess and validate the subclass when it is being initiated. It also defines an interpreter
        instance variable meant to be used by instances of the class. The class keeps track of all instances through
        a class-level dictionary '__all_instances__'.
    Attributes:
        __all_instances__ (dict[str, 'Model']): A class-level dictionary to keep track of all instances of the class.
            The keys are identifiers and values are instances.
        preprocessor (typing.ClassVar[type['Preprocessor']]): A class variable that points to a 'Preprocessor' class
            that should be used to preprocess the class upon initiation. It should be overridden in subclasses if preprocessing is required.
        validator (typing.ClassVar[type['Validator']]): A class variable that points to a 'Validator' class that should
            be used to validate the class upon initiation. It should be overridden in subclasses if validation is required.
        interpreter ('Interpreter'): An instance variable that is meant to hold an 'Interpreter' object which can be
            used by instances of the class.
    Methods:
        __init_subclass__(cls: type['Model'], **kwargs): Class method that automatically preprocesses and validates the class when
            a subclass is created. Calling 'preprocessor().preprocess(cls)' and 'validator().validate(cls)' if they are not None.
        __create__(**kwargs): Factory method that creates an instance and registers it in the '__all_instances__' dictionary.
            It returns the newly created instance.
    """
    __all_instances__: dict[str, "Model"] = {}
    preprocessor: typing.ClassVar[type["Preprocessor"]] = None
    validator: typing.ClassVar[type["Validator"]] = None
    interpreter: "Interpreter" = None

    def __init_subclass__(
        cls: type["Model"],
        **kwargs,
    ):
        """
        __init_subclass__ is a class method hook in Python for class initialization that allows for additional processing after a subclass of 'Model' is created.
            This method initializes a subclass of 'Model' by optionally running its associated preprocessor and validator, defined as class attributes. The preprocessor and validator are instances of 'Visitor' subclasses with methods prefixed by 'preprocess' and 'validate', respectively. They implement custom preprocessing and validation logic that get applied to the subclass during its initialization.
            Args:
                cls (type['Model']): The subclass being initialized.
            Keyword Args:
                **kwargs: Arbitrary keyword arguments that are passed to the parent class's __init_subclass__ method.
            Raises:
                Any exception raised by the preprocess or validate methods of the preprocessor or validator.
            Side Effects:
                The cls may be modified by the preprocessor and/or validator if they are specified.
            Notes:
                This method should not be called directly; it is automatically invoked by the Python runtime when a subclass of 'Model' is instantiated.
        """
        preprocessor = cls.preprocessor
        validator = cls.validator
        super().__init_subclass__(**kwargs)
        if preprocessor is not None:
            preprocessor().preprocess(cls)
        if validator is not None:
            validator().validate(cls)

    @classmethod
    def __create__(cls, **kwargs):
        """
            Create a new model instance and register it in the model's instances dictionary.
            This class method wraps the creation of a new instance using the inherited `__create__`
            method from its superclass and then registers the newly created instance in a class-level
            dictionary tracking all instances by their unique IDs.
            Attributes:
                cls: The class object that the method is being called on.
            Returns:
                The newly created instance of the class.
            Raises:
                ValueError: If any of the kwargs provided are invalid for the model's initialization.
            Note:
                This method uses `**kwargs` to allow passing a variable number of keyword arguments that
                are expected by the model's constructor.
        """
        self = super().__create__(**kwargs)
        Model.__all_instances__[self.__id__] = self
        return self


def of(element: ElementType) -> typing.Optional[typing.Union[type[Model], Model]]:
    """
    Retrieves the corresponding model or model type for a given ElementType element.
    This function looks up the '__all_elements__' dictionary attribute of the provided ElementType
    instance and attempts to find a value using the '__model__' attribute of that instance as a key.
    If the key exists in the dictionary, the function returns the associated model or model type.
    Otherwise, it returns None, indicating that no corresponding model or model type was found.
    Args:
        element (ElementType): The ElementType instance for which to retrieve the model or model type.
    Returns:
        Optional[Union[type[Model], Model]]: The model or model type associated with 'element', or None if not found.
    """
    return element.__all_elements__.get(element.__model__, None)


def all_instances() -> dict[str, Model]:
    """
    Returns a dictionary containing all instances of the Model class indexed by their identifiers.
    Returns:
        dict[str, Model]: A dictionary where the keys are string identifiers and the values are Model instances.
    """
    return Model.__all_instances__


def dump(
    element,
    level=0,
    associated_name=None,
):
    """
        Dump the structure and associations of an element recursively to the console.
        The function inspects an element, prints its name, type information, and unique identifier, and then recursively does the same for all elements owned by the initial element, as well as for all elements that it is associated with. The output is indented to reflect the hierarchy of elements.
        Parameters:
            element (ElementType): The element to be dumped. This can be a class, instance, or a more complex element structure with ownership and association relationships.
            level (int, optional): The current indentation level for printing. Defaults to 0, which means no indentation.
            associated_name (str, optional): An optional name that can represent an associated element. Defaults to None, in which case the name is generated based on the element and its relationships.
        Returns:
            None: This function does not return a value; its purpose is to print the structure of the element to the console.
    """
    type_or_object = "type" if isinstance(element, type) else "object"
    if associated_name is None:
        base = (
            element.__base__.__name__
            if type_or_object == "type"
            else element.__class__.__base__.__name__
        )
        type_name = f"{type_or_object}[{base}]"
    else:
        type_name = f"{type_or_object}[Association<{qualified_name_of(type_of(element))} @ {id_of(type_of(element))}>]"
    address = id_of(element)
    print(
        f"{level * ' '}{level} -> {associated_name if associated_name is not None else qualified_name_of(element)} {type_name} @ {address}"
    )
    if associated_name is None:
        for owned_element in owned_elements_of(element):
            dump(owned_element, level + 1)
        for name, associated in associations_of(element).items():
            if id_of(associated) not in element.__owned_elements__:
                dump(
                    associated,
                    level + 1,
                    f"{qualified_name_of(element)}.{name}",
                )
