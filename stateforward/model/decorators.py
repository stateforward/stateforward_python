"""


Module decorators

This module provides a decorator that allows a method to behave either as an instance method or a class method depending on how it's accessed.

Functions:
    instance_or_classmethod(decorated: Callable[P, R]) -> Callable[P, R]
        Wraps a callable object to create a descriptor that operates as both an instance method
        and a class method. This is beneficial when a method needs to be flexible enough to
        operate on an instance level and also be called directly from the class.

        Args:
            decorated (Callable[P, R]): The method or function to be wrapped by the decorator.

        Returns:
            Callable[P, R]: A callable that is a hybrid of an instance method and a class method. It
                            dynamically determines whether to behave as a class method or instance method based on the type of the object it is called on.

Note: Documentation automatically generated by https://undoc.ai
"""
from typing import Callable, ParamSpec, TypeVar

P = ParamSpec("P")
R = TypeVar("R")


def instance_or_classmethod(decorated: Callable[P, R]) -> Callable[P, R]:
    """
        Create a hybrid method that can be called as both a classmethod and an instancemethod.
        The `instance_or_classmethod` takes a callable and returns a callable that is able to act
        both as a classmethod when called on a class, and as a regular instance method
        when called on an instance of the class. It does this by defining a custom `__get__`
        method which determines whether the method should behave as a classmethod or
        an instance method based on the presence of the `instance` argument.
        Args:
            decorated (Callable[P, R]): The method to be decorated. It should be a callable that
                accepts the usual `self` parameter followed by any other parameters.
        Returns:
            Callable[P, R]: A callable that functions as a classmethod when `instance` is `None`
                and as a regular instance method when `instance` is not `None`. It effectively
                switches the behavior based on how the method is accessed.
        Note:
            It is important that the decorated method must be capable of handling calls
            both as a classmethod and an instance method, i.e., it must be designed in a
            way that it can handle the `self` parameter being either the instance or the
            class object. This utility is particularly useful when a method needs to behave
            differently based on the context in which it is called.
    """

    def __get__(self, instance, owner):
        """
        Implements the descriptor protocol's __get__ method, allowing instances of the class to behave like methods when accessed through class instances or the class itself.
        This method checks if it is being accessed through an instance or directly through the class. If accessed through an instance, it returns a bound method that can be called with the instance as its first argument. If accessed directly through the class, it returns a class method.
        Args:
            instance (object or None): The instance that the method is accessed through, or None if accessed through the class.
            owner (type): The class that the instance belongs to.
        Returns:
            The bound method or class method, depending on how the method was accessed.
        Raises:
            TypeError: If the required conditions for creating a bound or class method are not met.
        """
        if instance is None:
            return classmethod.__get__(self, instance, owner)
        return self.__func__.__get__(instance, owner)

    return type(
        decorated.__name__,
        (classmethod,),
        {"__get__": __get__},
    )(decorated)
