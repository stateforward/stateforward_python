"""


Module element
---------------

This module provides a framework for creating and managing element structures.
It includes a collection of functions and definitions for manipulating elements,
finding relationships between them, and dynamically creating element hierarchies.

Notable features include:
- Tracking ownership and associations between elements.
- Support for polymorphic element behavior with redefinition facilities.
- Element identification, attribute management, and inheritance support.

Classes:
- Element:
    A base class for creating element hierarchies with support for ownership,
    associations, and custom initialization procedures.

Functions:
- id_of(element: ElementType) -> int
    Retrieve a unique identifier for an element.

- type_of(element: ElementType) -> type['Element']
    Determine the type of the specified element.

- owned_elements_of(element: ElementType) -> Generator[ElementType, None, None]
    Iterate over elements owned by a given element.

- descendants_of(element: ElementType) -> Generator[ElementType, None, None]
    Generate all direct and indirect descendants of a given element.

- is_descendant_of(ancestor: ElementType, descendant: ElementType) -> bool

- ancestors_of(element: ElementType) -> Generator[ElementType, None, None]
    Iterate over all ancestors of a given element.

- is_ancestor_of(descendant: ElementType, ancestor: ElementType) -> bool

- set_model(element: ElementType, model: ElementType)
    Set the model for an element and its owned elements.

- set_owner(element: ElementType, owner: ElementType)
    Set the owner for an element and its owned elements.

- add_owned_element_to(owner: ElementType, element: ElementType, name: str=None, *, change_ownership: bool=False)

- remove_owned_element_from(owner: ElementType, element: ElementType, *, disassociate: bool=False) -> ElementType

- remove_owned_elements_from(owner: ElementType, *owned_elements: typing.Collection[ElementType]) -> typing.Collection[ElementType]

- add_association_to(owner: ElementType, element: ElementType, name: str=None)

- remove_association_from(owner: ElementType, element: ElementType)

- associations_of(element: ElementType) -> dict[str, ElementType]

- name_of(element: ElementType) -> str

- attributes_of(element: ElementType) -> dict[str, typing.Any]

- qualified_name_of(element: ElementType) -> str

- is_type(element: ElementType, types: typing.Union[type, typing.Collection[type]]) -> bool

- is_subtype(element: ElementType, types: typing.Union[type, typing.Collection[type]]) -> bool

- is_element(value: typing.Any) -> bool

- owner_of(element: ElementType) -> ElementType

- redefined_element_of(element: ElementType) -> ElementType

- is_owner_of(owner: ElementType, element: ElementType) -> bool

- specialize(base: ElementType, derived: ElementType, **kwargs)

- is_redefined(element: ElementType) -> bool

- redefine(element: ElementType, **kwargs)

- find_owned_elements_of(element: 'ElementType', condition: typing.Callable[['ElementType'], bool]) -> Generator['ElementType', None, None]

- find_owned_element_of(element: 'ElementType', condition: typing.Callable[['ElementType'], bool]) -> typing.Optional['ElementType']

- find_ancestors_of(element: 'ElementType', condition: typing.Callable[['ElementType'], bool]) -> Generator['ElementType', None, None]

- find_ancestor_of(element: 'ElementType', expr: typing.Callable[['ElementType'], bool]) -> typing.Optional['ElementType']

- find_descendants_of(element: 'ElementType', condition: typing.Callable[['ElementType'], bool]) -> Generator['ElementType', None, None]

- set_attribute(element: ElementType, name: str, value: typing.Any)

- new(name: str, bases: typing.Collection[type]=None, **kwargs) -> type[T]

TypeVars:
- ElementType: A type variable bound to either 'Element' or derived types.
- T: A generic type bound to 'Element'.

Exceptions:
- ValueError: If operations are performed that violate ownership or association rules.

Note: Documentation automatically generated by https://undoc.ai
"""
import typing
import types

ElementType = typing.TypeVar(
    "ElementType", bound=typing.Union[type["Element"], "Element"]
)
T = typing.TypeVar("T", bound="Element")


def id_of(element: ElementType) -> int:
    """
    Returns the unique identifier of an 'element'.
        The function attempts to retrieve an '__id__' attribute from the 'element'. If the '__id__'
        attribute does not exist, it falls back to using the built-in 'id' function to generate
        a unique identifier for the 'element'.
        Args:
            element (ElementType): The element for which the identifier is to be obtained.
        Returns:
            int: The unique identifier for the 'element'. This might be the '__id__' attribute
                 of the 'element' if it exists; otherwise, it is the identifier returned by
                 the built-in 'id' function.
    """
    return getattr(element, "__id__", id(element))


def type_of(element: ElementType) -> type["Element"]:
    """
    Determines the type of the given element. It retrieves the type information of the passed element object using a special attribute `__type__` which should be defined within the `ElementType` instance. This function is useful in introspecting the type information of elements which hold their type internally and non-standardly as `__type__` instead of the typical `__class__` attribute. Note that `ElementType` seems to be a custom type hint which should be defined elsewhere in the code. The function returns the type of the element as specified by its `__type__` attribute which is expected to be a subclass of the `Element` type or a type hint indicating such a subclass. This allows for dynamic type checking or retrieval in systems that define custom element types with associated metadata. It's important to ensure that `ElementType` instances have the `__type__` attribute correctly set to avoid any AttributeError exceptions when this function is called. Clients of this function should handle the possibility of such exceptions if the `ElementType` contract is not strictly enforced elsewhere in the system. The returned type can be used for further reflection or type enforcement in client code.
    """
    return element.__type__


def owned_elements_of(
    element: ElementType,
) -> typing.Generator[ElementType, None, None]:
    """
        Generator function that yields elements owned by the given element.
        This function iterates over the IDs of elements owned by the provided element object and yields each corresponding element from a collection of all elements.
        Args:
            element (ElementType): The element whose owned elements are to be retrieved. It must have an attribute `__owned_elements__` which is an iterable of element IDs (typically a list or tuple), and an attribute `__all_elements__` which is a collection (such as a dictionary) containing all possible elements indexed by their ID.
        Yields:
            ElementType: The elements owned by the provided element object.
        Raises:
            AttributeError: If the provided element object does not have the `__owned_elements__` or `__all_elements__` attributes necessary for the function to retrieve owned elements.
    """
    for owned_element_id in element.__owned_elements__:
        yield element.__all_elements__[owned_element_id]


def descendants_of(element: ElementType) -> typing.Generator[ElementType, None, None]:
    """
    Generates an iterator over all descendant elements of a given element.
        This function recursively retrieves all elements owned by the given element
        and its subsequent owned elements. It traverses the ownership tree and
        yields every descendant element, effectively flattening the hierarchy.
        Args:
            element (ElementType): The element whose descendants are to be retrieved.
        Yields:
            ElementType: The next descendant element in the ownership hierarchy.
    """
    for owned_element in owned_elements_of(element):
        yield owned_element
        yield from descendants_of(owned_element)


def is_descendant_of(ancestor: ElementType, descendant: ElementType) -> bool:
    """
    Determines whether an element is a descendant of a specified ancestor element.
    Args:
        ancestor (ElementType): The element that is to be checked as the ancestor.
        descendant (ElementType): The element that is to be checked if it is a descendant.
    Returns:
        bool: True if the 'descendant' is a descendant of the 'ancestor', otherwise False.
    """
    return (
        next(
            (element for element in descendants_of(ancestor) if element == descendant),
            None,
        )
        is not None
    )


def ancestors_of(element: ElementType) -> typing.Generator[ElementType, None, None]:
    """
    Retrieves an iterator over the ancestors of a given element.
        This function creates a generator that navigates from the given element up the ownership hierarchy,
        yielding each ancestor element successively until reaching a top-level element that has no owner.
        Args:
            element (ElementType): The element for which to retrieve ancestors.
        Returns:
            Generator[ElementType, None, None]: A generator yielding ancestor elements of the provided element.
        Note:
            The generator stops when it reaches an element that does not have an owner.
        Raises:
            TypeError: If the element is not an instance of the expected ElementType.
    """
    owner = owner_of(element)
    if owner is not None:
        yield owner
        yield from ancestors_of(owner)


def is_ancestor_of(descendant: ElementType, ancestor: ElementType) -> bool:
    """
    Checks whether a given element is an ancestor of another element.
    Args:
        descendant (ElementType): The element to check as a descendant.
        ancestor (ElementType): The element to check as an ancestor.
    Returns:
        bool: True if the `ancestor` is an ancestor of the `descendant`, False otherwise.
    """
    return is_descendant_of(ancestor, descendant)


def set_model(element: ElementType, model: ElementType):
    """
    Sets the model attribute of an element to the identifier of the given model and recursively applies the same operation to all owned elements.
    This function takes an ElementType instance, computes its model identifier using the `id_of` function, and assigns it to the `__model__` attribute of the element. It then iterates over all owned elements (retrievable via the `owned_elements_of` generator) and calls itself on each sub-element to propagate the model's identifier throughout the hierarchy of owned elements.
    Args:
        element (ElementType): The element for which the model is to be set.
        model (ElementType): The model element whose identifier is to be applied to the element and its owned elements.
    Returns:
        None
    """
    element.__model__ = id_of(model)
    for owned_element in owned_elements_of(element):
        set_model(owned_element, model)


def set_owner(element: ElementType, owner: ElementType):
    """
        Sets the owner of the given element and recursively sets the owner for all owned elements.
        This function assigns an owner to the specified element by setting the element's `__owner__` attribute
        to the identifier of the owner. It then proceeds to recursively apply the same operation to all elements
        owned by the initial element, effectively setting up the ownership hierarchy. Additionally,
        it establishes the model to which the element belongs by calling `set_model` with the element and its
        owner's model.
        Args:
            element (ElementType): The element to which an owner is being assigned.
            owner (ElementType): The element that will take ownership.
        Raises:
            AttributeError: If `__owner__`, `__all_elements__`, or `__model__` attributes do not exist on the element.
    """
    element.__owner__ = id_of(owner)
    for owned_element in owned_elements_of(element):
        set_owner(owned_element, element)
    set_model(element, element.__all_elements__[owner.__model__])


def add_owned_element_to(
    owner: ElementType,
    element: ElementType,
    name: str = None,
    *,
    change_ownership: bool = False,
):
    """
    def add_owned_element_to(owner: ElementType, element: ElementType, name: str=None, *, change_ownership: bool=False):
        Adds an element to the list of elements owned by a specified owner.
        Given an element and an owner, this function sets the element's ownership to the specified
        owner and adds the element's identifier to the owner's list of owned elements.
        Optionally, a name can be assigned to the element within the context of its owner.
        If the element already has an owner and `change_ownership` is set to `True`, the element
        is first disassociated from the current owner before being reassigned.
        Args:
            owner (ElementType): The owner to which the element will be added.
            element (ElementType): The element to be owned.
            name (str, optional): The name to assign to the element within the owner's context.
                Defaults to None. The functionality related to setting the element's name
                based on this parameter is commented out and thus not implemented.
            change_ownership (bool, optional): A flag to indicate whether to force change of ownership
                in case the element already has an owner. Defaults to False. If set to True,
                the element is removed from its previous owner before being reassigned.
        Raises:
            ValueError: If the element already has an owner and `change_ownership` is False.
        Returns:
            ElementType: The element which has now been associated with the specified owner.
    """
    element_owner = owner_of(element)
    if element_owner is not None:
        if not change_ownership:
            raise ValueError(f"element {element.__name__} already has an owner")
        remove_owned_element_from(element_owner, element)
    set_owner(element, owner)
    owner.__owned_elements__.append(id_of(element))
    # if name is not None and not is_collection(owner):
    #     element.__name__ = name
    #     element.__qualname__ = f"{owner.__qualname__}.{name}"


def remove_owned_element_from(
    owner: ElementType, element: ElementType, *, disassociate: bool = False
) -> ElementType:
    """
        Removes an owned element from its owner and optionally disassociates it from other elements.
        This function removes the element identified by 'element' from the '__owned_elements__' list
        of the 'owner' provided. If the 'disassociate' flag is set to True, it will also remove any
        associations between the 'element' and other elements in the '__associations__' mapping.
        Args:
            owner (ElementType): The owner of the element that is to be removed.
            element (ElementType): The element to be removed from its owner.
            disassociate (bool, optional): A flag indicating whether to remove associations of the 'element'
                                          with other elements. Defaults to False.
        Returns:
            ElementType: The element that has been removed.
        Raises:
            ValueError: If the element is not owned by the owner.
    """
    element_id = id_of(element)
    if owner_of(element) != owner:
        raise ValueError(f"element {element.__name__} is not owned by {owner.__name__}")
    if disassociate:
        for name, element in associations_of(element).items():
            remove_association_from(owner, element)
    owner.__owned_elements__.remove(element_id)
    element.__owner__ = None
    return element


def remove_owned_elements_from(
    owner: ElementType, *owned_elements: typing.Collection[ElementType]
) -> typing.Collection[ElementType]:
    """
    Removes a collection of owned elements from a specified owner element.
    This function takes an owner element of type `ElementType` and a variable
    number of arguments representing collections of elements, also of type
    `ElementType`, that are owned by the owner. It removes each element in
    the collections from the owner. If no collections are provided, it retrieves
    the owned elements by calling the `owned_elements_of` function. Once the owned
    elements are determined, it removes them using the `remove_owned_element_from`
    function and returns them as a tuple.
    Args:
        owner (ElementType): The element from which the owned elements are to be removed.
        *owned_elements (typing.Collection[ElementType]): Variable number of arguments,
            each representing a collection of elements to be removed from the owner.
    Returns:
        typing.Collection[ElementType]: A collection (tuple) of all the elements that were
            removed from the owner.
    """
    if not owned_elements:
        owned_elements = tuple(owned_elements_of(owner))
    removed_elements = tuple(
        remove_owned_element_from(owner, owned_element)
        for owned_element in owned_elements
    )
    return removed_elements


def add_association_to(owner: ElementType, element: ElementType, name: str = None):
    """
    Adds an association between two elements with an optional name.
        This function creates an association between the 'owner' and 'element' by
        assigning the id of the 'element' to the 'owner's '__associations__' dictionary
        using the provided 'name' as a key. If no 'name' is provided, the association
        is still created but without a specific name. The unique identifier of the
        'element' is retrieved using the 'id_of' function.
        Args:
            owner (ElementType): The element to which the association is being added.
            element (ElementType): The element that is being associated with the 'owner'.
            name (str, optional): A name for the association. Defaults to None.
    """
    owner.__associations__[name] = id_of(element)


def remove_association_from(owner: ElementType, element: ElementType):
    """
    Removes a specified association between a owner object and an element object in a separate collection within the owner.
    The function traverses through the association dictionary of the owner to find a matching element.
    If a matching element is found, it is then removed from the owner's associations.
    Args:
        owner (ElementType): The object from which the association will be removed.
        element (ElementType): The element to be disassociated from the owner object.
    Raises:
        KeyError: If the association does not exist or has already been removed, a KeyError may be raised when attempting to delete the non-existent key.
    """
    for name, element in associations_of(owner).items():
        if element == element:
            del owner.__associations__[name]


def associations_of(element: ElementType) -> dict[str, ElementType]:
    """
    Returns a dictionary of associations for a given ElementType instance.
    This function constructs a dictionary where each key-value pair represents an association
    name and the corresponding element respectively. It utilizes the internals of the given
    ElementType instance to resolve these associations.
    Args:
        element (ElementType): The ElementType instance whose associations are to be retrieved.
    Returns:
        dict[str, ElementType]: A dictionary with keys as association names and values as ElementType
                               instances associated with the given element.
    Raises:
        KeyError: If an association id can't be found in the element's __all_elements__ mapping.
        AttributeError: If the given element does not have the required __all_elements__ or
                        __associations__ attributes.
    """
    return dict(
        (name, element.__all_elements__[element_id])
        for name, element_id in element.__associations__.items()
    )


def associations_for(
    element: ElementType, associated: ElementType
) -> dict[str, ElementType]:
    """
        Retrieves a dictionary of associations between the given element and an associated element.
        Scans through the associations of the `element` searching for those that have the same ID
        as the `associated` element, then returns a dictionary where the keys are the names of
        the associations and the values are the associated elements themselves.
        Args:
            element (ElementType): The element for which to find associations.
            associated (ElementType): The element that should be associated with the given element.
        Returns:
            dict[str, ElementType]: A dictionary comprising the names of the associations as keys
                and the associated ElementType instances as values, filtered by those matching the
                ID of the `associated` element.
    """
    return dict(
        (name, element.__all_elements__[element_id])
        for name, element_id in element.__associations__.items()
        if element_id == id_of(associated)
    )


def name_of(element: ElementType) -> str:
    """
        Retrieve the name of the provided element.
        This function takes an element which could be a type (class) or an instance of a class and
        returns the name of the class itself or the name of the class that the instance belongs to.
        Args:
            element (ElementType): The element (type or instance) for which the name is to be retrieved.
        Returns:
            str: The name of the element's type or class.
    """
    return element.__name__ if isinstance(element, type) else element.__class__.__name__


def attributes_of(element: ElementType) -> dict[str, typing.Any]:
    """
        Retrieves the annotations of attributes for an ElementType object.
        The function inspects a given ElementType instance and extracts its
        annotations using the `__annotations__` attribute. These annotations typically
        represent the expected types for the attributes of the ElementType.
        Args:
            element (ElementType): The instance of ElementType for which to retrieve attribute annotations.
        Returns:
            dict[str, typing.Any]: A dictionary where the keys are attribute names
            and the values are the types indicated by the annotations.
    """
    return element.__annotations__


def qualified_name_of(element: ElementType) -> str:
    """
        Determines the fully qualified name of the given element.
        A fully qualified name is the complete dot-separated path needed to access the element from the global scope.
        For example, given a class `C` defined inside a module `M`, its fully qualified name would be `M.C`.
        This function first retrieves the owner of the given element and, if the owner exists, constructs the fully qualified name
        by recursively fetching the owner's qualified name and appending the current element's name.
        If the element has no owner, it simply returns the name of the element.
        Args:
            element (ElementType): The element whose fully qualified name is to be obtained. Expected to be an instance or class
                                 that has the `__owner__` attribute or is present in the `__all_elements__` mapping of its owner.
        Returns:
            str: The fully qualified name of the element.
    """
    owner = owner_of(element)
    if owner is None:
        return name_of(element)
    return f"{qualified_name_of(owner)}.{name_of(element)}"


def is_type(
    element: ElementType, types: typing.Union[type, typing.Collection[type]]
) -> bool:
    """
    Checks if the given element is of the specified type or types.
        This function can handle both type objects and instances. It uses 'issubclass' when 'element' is a type object, 'isinstance' otherwise.
        Args:
            element (ElementType): The element to check.
            types (Union[type, Collection[type]]): A single type or a collection of types to check against.
        Returns:
            bool: True if 'element' is a type and a subclass of 'types', or if 'element' is an instance and an instance of 'types'. False otherwise.
    """
    return (
        issubclass(element, types)
        if isinstance(element, type)
        else isinstance(element, types)
    )


def is_subtype(
    element: ElementType, types: typing.Union[type, typing.Collection[type]]
) -> bool:
    """
    Checks whether a given element is a subtype of the specified type(s) and not actually one of the types given.
    Args:
        element (ElementType): The element to check.
        types (typing.Union[type, typing.Collection[type]]): The type or collection of types to check against.
    Returns:
        bool: True if the element is a subtype of one or more types in the given collection and is not any of the types provided; otherwise, False.
    Raises:
        TypeError: If 'types' is not a type or a collection of types.
    """
    if is_element(types):
        types = (types,)
    return element not in types and is_type(element, types)


def is_element(value: typing.Any) -> bool:
    """
        Check if the value is an instance of the Element class or a subclass thereof.
        Args:
            value (typing.Any): The value to be checked.
        Returns:
            bool: True if the value is an instance or subclass of Element, False otherwise.
    """
    return is_type(value, Element)


def owner_of(element: ElementType) -> ElementType:
    """
        Retrieves the owner of the specified element.
        The `owner_of` function takes an element which could be of any defined ElementType and
        returns the owner of that element. If the provided element is an instance of Element,
        it directly returns the owner from the element's `__owner__` attribute. If the element is not an instance of Element,
        it attempts to retrieve the owner from a mapping called `__all_elements__` using the element's `__owner__` as a key.
        Args:
            element (ElementType): The element for which the owner information is being requested.
        Returns:
            ElementType: The owner of the provided element if found, or None if either the element is not an
            instance of Element or the owner cannot be found in `__all_elements__`.
    """
    return (
        element.__owner__
        if isinstance(element, Element)
        else element.__all_elements__.get(element.__owner__, None)
    )


def redefined_element_of(element: ElementType) -> ElementType:
    """
    Returns the redefined representation of the given element.
        This function expects an object of ElementType which has an attribute `__redefined_element__` that holds
        a redefined version of the element. It retrieves this attribute from the object and returns it. The function
        is designed to work with instances that conform to this interface, and the behavior is unspecified if
        `__redefined_element__` is not an attribute of the input object.
        Args:
            element (ElementType): An object of ElementType which contains a redefined version as an attribute.
        Returns:
            ElementType: The redefined version of the element as specified in `__redefined_element__`.
        Raises:
            AttributeError: If the `__redefined_element__` attribute does not exist on the input element.
    """
    return element.__redefined_element__


def is_owner_of(owner: ElementType, element: ElementType) -> bool:
    """
    Determines whether the specified owner is the owner of the given element.
        This function checks if the given 'owner' is the owner of the specified 'element'.
        Ownership is determined by comparing the owner of 'element' with the specified 'owner'.
        Args:
            owner (ElementType): The potential owner to be verified against the element.
            element (ElementType): The element whose ownership is to be checked.
        Returns:
            bool: True if 'owner' is the owner of 'element', otherwise False.
    """
    return owner_of(element) == owner


def specialize(base: ElementType, derived: ElementType, **kwargs):
    """
    Describes the process of creating a specialized version of an element, including duplicating owned elements and remapping associations.
    Args:
        base (ElementType): The base element from which the specialized version is derived.
        derived (ElementType): The element that represents the specialized version of the base.
        **kwargs: Variable keyword arguments that are currently not used but might be provided for future extensions.
    Returns:
        None: The function does not return any value.
    Side Effects:
        Modifies `derived` by adding new owned elements that are specialized versions of `base`'s owned elements.
        Establishes new associations in `derived` by remapping the associations of `base` to the corresponding new specialized elements.
    Raises:
        TypeError: If the created new class for the owned elements does not satisfy the requirements of being an `ElementType`.
    """
    # we have to create copies of the base elements during inheritance
    # loop through base owned element mapping
    for owned_element_id in base.__owned_elements__:
        # get the owned element
        owned_element = base.__all_elements__[owned_element_id]
        # create a new owned element
        new_owned_element = typing.cast(
            ElementType,
            types.new_class(
                owned_element.__name__,
                (owned_element,),
                {
                    "redefined_element": base,
                },
            ),
        )
        add_owned_element_to(derived, new_owned_element)

    if owner_of(base) is None:
        base_elements = (base, *descendants_of(base))
        new_elements = (derived, *descendants_of(derived))
        element_map = dict(
            (id_of(base), id_of(derived))
            for base, derived in zip(base_elements, new_elements)
        )

        for index, element in enumerate(base_elements):
            new_element = new_elements[index]
            for name, element_id in element.__associations__.items():
                associated_id = new_element.__associations__[name] = element_map[
                    element_id
                ]
                setattr(new_element, name, new_element.__all_elements__[associated_id])
    return None


def is_redefined(element: ElementType) -> bool:
    """
    Determines if the given element has been redefined.
    This function checks if the element passed to it has an attribute `__redefined_element__` which is not `None`. Essentially, it checks if the `redefined_element_of` function applied to the element returns a value that is not `None`, indicating that the element has indeed been redefined.
    Args:
        element (ElementType): The element to check for redefinition.
    Returns:
        bool: True if the element has been redefined, otherwise False.
    """
    return redefined_element_of(element) is not None


def redefine(element: ElementType, **kwargs):
    """
        Redefines an existing element by creating a new class with the same name, inheriting from the original element.
        This function dynamically creates a new class based on the provided `element`. The new class will inherit
        from the original `element` class and will include any additional keyword arguments passed to this function
        as class-level attributes.
        Args:
            element (ElementType): The base class from which the new class will inherit.
            **kwargs: Arbitrary keyword arguments that will be included as attributes in the new class.
        Returns:
            ElementType: A new class that inherits from `element` and contains the additional class-level
            attributes as specified in `kwargs`.
        Raises:
            TypeError: If the `name_of` function does not return a string, which is required for the class name.
    """
    return typing.cast(
        ElementType,
        types.new_class(
            name_of(element),
            (element,),
            {
                "redefined_element": element,
                **kwargs,
            },
        ),
    )


def find_owned_elements_of(
    element: "ElementType", condition: typing.Callable[["ElementType"], bool]
) -> typing.Generator["ElementType", None, None]:
    """
    Iterates over elements owned by a given element and yields those that meet a specified condition.
    Args:
        element (ElementType): The element whose owned elements are to be examined.
        condition (Callable[[ElementType], bool]): A function that takes an ElementType as an argument and returns a boolean value.
            The condition is used to determine which owned elements should be yielded.
    Yields:
        ElementType: An owned element of the 'element' argument that satisfies the 'condition' callable.
    """
    for owned_element in owned_elements_of(element):
        if condition(owned_element):
            yield owned_element


def find_owned_element_of(
    element: "ElementType", condition: typing.Callable[["ElementType"], bool]
) -> typing.Optional["ElementType"]:
    """
    Finds the first element owned by a particular element that satisfies a given condition.
        This function searches through the elements owned by the provided element, and returns the first one
        that meets the condition specified by the 'condition' callable. If no such element exists, it returns None.
        Args:
            element (ElementType): The element to search within for owned elements.
            condition (Callable[[ElementType], bool]): A function that takes an 'ElementType' as its
                 argument and returns a boolean value. This function is used to test each owned element
                 to determine if it satisfies the given condition.
        Returns:
            Optional[ElementType]: The first owned element that satisfies the 'condition' callable, or None
                if no such element is found.
    """
    return next(find_owned_elements_of(element, condition), None)


def find_ancestors_of(
    element: "ElementType", condition: typing.Callable[["ElementType"], bool]
) -> typing.Generator["ElementType", None, None]:
    """
    Finds and yields all ancestors of a given element that satisfy a specified condition.
    This function iterates over all ancestors of the provided element and yields
    those which satisfy a user-defined condition. An ancestor is considered
    as any element that can be reached by recursively obtaining the owner
    of the original element. The condition is a callable that takes
    an element as an argument and returns a boolean value.
    Args:
        element (ElementType): The element for which to find ancestors.
        condition (typing.Callable[['ElementType'], bool]): A callable that takes
            an ElementType as an argument and returns a boolean. If the callable
            returns True, the element is yielded by the generator.
    Yields:
        ElementType: An ancestor of the input element that satisfies the condition.
    """
    for element in ancestors_of(element):
        if condition(element):
            yield element


def find_ancestor_of(
    element: "ElementType", expr: typing.Callable[["ElementType"], bool]
) -> typing.Optional["ElementType"]:
    """
        Finds the closest ancestor of the given element that matches the specified condition.
        This function traverses the ancestry of the provided element and returns the first ancestor
        for which the given callable `expr` returns True. If no such ancestor exists, None is returned.
        Args:
            element (ElementType): The element whose ancestors are to be searched.
            expr (Callable[[ElementType], bool]): A function that takes an element as its argument
                and returns a boolean value indicating whether the element matches the condition.
        Returns:
            Optional[ElementType]: The first ancestor element that satisfies the condition `expr`,
                or None if no such element is found.
    """
    return next(find_ancestors_of(element, expr), None)


def find_descendants_of(
    element: "ElementType",
    condition: typing.Callable[["ElementType"], bool],
) -> typing.Generator["ElementType", None, None]:
    """
    Generates a sequence of descendant elements that satisfy a given condition.
        Args:
            element (ElementType): The element whose descendants are to be examined.
            condition (typing.Callable[['ElementType'], bool]): A callable that takes an ElementType
                as input and returns a boolean indicating whether the element satisfies the condition.
        Yields:
            typing.Generator['ElementType', None, None]: A generator of ElementType objects that are
                descendants of the input element and satisfy the condition.
        This function recursively searches through the descendants of the provided element using
        the `descendants_of` function. It checks each descendant to see if it satisfies the given
        condition, and if so, yields that element.
    """
    for element in descendants_of(element):
        if condition(element):
            yield element


def set_attribute(
    element: ElementType,
    name: str,
    value: typing.Any,
):
    """
    Sets an attribute for a given ElementType with optional ownership and association handling. 
    Args:
        element (ElementType): 
            The element on which to set the attribute. 
        name (str): 
            The name of the attribute to set. 
        value (typing.Any): 
            The value to assign to the attribute. This can be a simple data type or an ElementType. 
    Raises:
        ValueError:
            If the value is an ElementType that already belongs to a different owner and
            cannot change ownership.
    Note:
        If the value is an ElementType and it is not already owned by the provided
        element, ownership rules are applied. The function will check if the value
        can be changed to the new ownership and update the associations accordingly.
        1. If the value has no owner or is a descendant of the 'element', and both
           have the same model, ownership change is allowed without raising an error.
        2. The function will raise a ValueError if the change of ownership is not
           permitted but attempted.
        3. After the potential ownership change, the association between 'element'
           and value is registered using the provided 'name' as the association name. 
    """
    if is_element(value):
        value_id = id_of(value)
        if value_id not in element.__owned_elements__:
            owner = owner_of(value)
            change_ownership = (
                owner is None or is_descendant_of(element, owner)
            ) and element.__model__ != id_of(value)
            if change_ownership:
                add_owned_element_to(
                    element, value, name, change_ownership=change_ownership
                )
        add_association_to(element, value, name)
    setattr(element, name, value)


def new(name: str, bases: typing.Collection[type] = None, **kwargs) -> type[T]:
    """
    Creates a new type with the specified name, optional base classes, and additional attributes.
    Args:
        name (str): The name of the new type to create.
        bases (typing.Collection[type]): An optional collection of base classes from which the new type will inherit. If not supplied, the base will default to (Element,).
        **kwargs: Arbitrary keyword arguments representing additional attributes to add to the new type.
    Returns:
        type[T]: A new type that is cast to the specified generic type variable T.
    """
    return typing.cast(
        type[T],
        types.new_class(
            name,
            bases or (Element,),
            {
                **kwargs,
            },
        ),
    )


P = typing.ParamSpec("P")


class Element(typing.Generic[T]):
    """
    A base class for representing a generic element with extended functionality for subclassing and component management.
    This class implements mechanisms to keep track of instances and their properties, facilitate inheritance and redefinition of elements, and provide a system to create and manage associations between elements. It employs advanced typing and callable constructs to establish these sophisticated behaviors.
    Attributes:
        __all_elements__ (dict[int, 'ElementType']): Class-level storage mapping element IDs to element instances.
        __id__ (int): A unique identifier that increments with each subclass.
        __owned_elements__ (list[int]): A list of owned elements represented by their IDs.
        __redefined_element__ (Optional['Element']): An element that this one redefines, if applicable.
        __associations__ (dict[str, int]): A mapping of association names to their respective element IDs.
        __owner__ (Optional[int]): The ID of the owning element if this element is owned.
        __type__ (type['Element']): The class type of the element.
        __model__ (Optional[int]): The ID of the model element to which this element belongs.
        __init__ (Callable[P, None]): A lambda function serving as a placeholder for the __init__ method.
        model (Optional['Element']): The model element associated with this instance.
    Class Methods:
        __init_subclass__: Automates several processes when creating a new subclass of Element, such as ID assignment, model association, and inheriting annotations from base classes.
        __define__: Sets up owned elements from the provided keyword arguments and organizes class namespace.
        __redefine__: A placeholder method for redefining elements that may be implemented in subclasses.
        __create__: Creates a new instance of the class and initializes its associations and owned elements.
        __create_owned_elements__: Responsible for instantiating and managing owned elements.
    Static Methods:
        __new__: Controls the instantiation process of elements, ensuring proper associations and initialization.
    This class is typically used as a base class for creating complex hierarchical structures with a clear definition of ownership and associations. It should not be instantiated directly but subclassed to create more specific element types.
    """

    __all_elements__: dict[int, "ElementType"] = {}
    __id__: typing.ClassVar[int] = 0
    __owned_elements__: list[int] = None
    __redefined_element__: typing.Optional["Element"] = None
    __associations__: dict[str, int] = None
    __owner__: typing.Optional[int] = None
    __type__: typing.ClassVar[type["Element"]] = None
    __model__: typing.Optional[int] = None
    __init__: typing.Callable[P, None] = lambda *args, **kwargs: None
    model: typing.Optional["Element"] = None

    def __init_subclass__(cls, **kwargs):
        """
        Initializes a subclass of an Element type, setting various class-level attributes necessary for the metamodeling system.
        The method handles the initialization process when a subclass of the Element class is created, ensuring the proper setting of owned elements, associations, identifiers, and model references, as well as handling type redefinition when applicable.
        Args:
            **kwargs (dict): A variable keyword argument dictionary. Potential keywords include:
                'name' (str): The name to assign to the subclass. If not provided, the base class name is retained.
                'redefined_element' (Element): The Element that is being redefined by the current subclass.
        Raises:
            TypeError: If required attributes or arguments are missing in the keyword arguments to properly create or redefine the subclass.
        """
        cls.__owned_elements__ = []
        cls.__id__ = Element.__id__ = Element.__id__ + 1
        cls.__model__ = cls.__id__
        cls.__all_elements__[cls.__id__] = cls
        cls.__associations__ = {}
        cls.__type__ = cls
        cls.__owner__ = None
        cls.__name__ = kwargs.pop("name", cls.__name__)
        redefined_element = cls.__redefined_element__ = kwargs.pop(
            "redefined_element", None
        )
        if is_subtype(cls.__base__, Element):
            cls.__annotations__.update(cls.__base__.__annotations__)
            specialize(cls.__base__, cls)
        if redefined_element is None:
            cls.__define__(**kwargs)
        else:
            cls.__redefine__(**kwargs)

    @classmethod
    def __define__(cls, **kwargs):
        """
        Add owned elements and set attributes on an Element class during class construction.
                This class method is used in the class construction process to define
                class attributes and their associations for an Element class. It operates
                by taking a series of keyword arguments that represent different parts of
                the class definition, handling owned elements, and setting other attributes
                accordingly.
                Parameters:
                    **kwargs: Arbitrary keyword arguments.
                        Each keyword argument represents an attribute to set on the class.
                        Special keyword 'owned_elements' is expected to be an iterable of
                        elements that the class will own.
                Returns:
                    None: This method operates in place and modifies class attributes
                        directly, thus it has no return value.
                Raises:
                    Various exceptions can be raised depending on the implementation details
                        of functions called within this method (e.g., 'add_owned_element_to',
                        'id_of', 'is_element', 'owner_of', 'set_attribute').
                Note:
                    This method decorates a class method with classmethod.
        """
        for owned_element in kwargs.get("owned_elements", ()):
            add_owned_element_to(cls, owned_element)

        def sort_namespace(namespace: dict[str, typing.Any]) -> dict[str, typing.Any]:
            """
            Sorts a given namespace dictionary into a new dictionary, categorizing its items as orphans, owned, and attributes.
            This function processes a namespace dictionary which contains identifiers (keys) and their corresponding elements (values).
            It assesses each element to establish its relationship with the Element class. Based on the assessment, each item is
            categorized as an orphan (no identified owner), owned (has an associated 'owner_of' member), or attribute (neither of the first
            two cases, typically normal attributes or methods). Items categorized as orphans are those that don't explicitly belong to
            any class; owned items are those that have an associated owner object; attributes are other elements that do not fall
            into the first two categories. The resulting dictionary is a merge of these three categories, with orphans coming
            first, followed by owned items, and finally attributes to maintain a categorized order in the namespaced items.
            Parameters:
                namespace (dict[str, typing.Any]): The namespace dictionary to be sorted, where keys are string identifiers
                    of the namespace members, and values are the corresponding elements (may include classes, functions, etc.).
            Returns:
                dict[str, typing.Any]: A new sorted dictionary with elements categorized as orphans, owned, and attributes.
            The sorted dictionary maintains a sequence with orphans at the beginning, followed by owned entries and attributes.
            """
            owned = {}
            orphans = {}
            attributes = {}
            for key, item in namespace.items():
                if key not in Element.__dict__:
                    item_id = id_of(item)
                    if is_element(item):
                        if owner_of(item) is None:
                            orphans[key] = (item_id, item)
                        else:
                            owned[key] = (item_id, item)
                    else:
                        attributes[key] = (item_id, item)

            return {**orphans, **owned, **attributes}

        sorted_namespace = sort_namespace(
            {
                **cls.__dict__,
                **dict(
                    (name, kwargs.get(name, getattr(cls, name, None)))
                    for name in cls.__annotations__
                ),
            },
        )
        for name, (item_id, item) in sorted_namespace.items():
            set_attribute(cls, name, item)

    @classmethod
    def __redefine__(cls, **kwargs):
        """
        A class method that provides a mechanism to dynamically redefine class attributes.
                This method accepts keyword arguments where each key represents the attribute
                name to be redefined, and the corresponding value represents the new value
                for that attribute. The method is a placeholder and expected to be overridden
                by subclasses as needed.
                Args:
                    **kwargs: Arbitrary keyword arguments where each key-value pair
                        specifies the attribute to be redefined and its new value.
                Returns:
                    None: This method is not expected to return any value. It is meant
                        to be used for side effects such as updating class attributes.
        """
        pass

    @classmethod
    def __create__(cls, **kwargs) -> "Element":
        """
        Creates a new instance of the class `Element` or its subclass with given keyword arguments.
        This class method constructs a new instance by invoking the super class's `__new__` method, setting up
        owner reference (if provided), initializing a list to track owned elements, and assigning a unique ID.
        It also links the instance to the model of the owner element if an owner is provided, or designates
        the instance itself as the model. All elements including the new instance are stored in a namespace
        dictionary. The method finally calls an internal classmethod to create any owned elements.
        Args:
            **kwargs: Arbitrary keyword arguments.
                owner (Optional): The owner of this element, default is None.
                id (Optional): The unique identifier for this element, defaults to the Python `id` of the instance.
                all_elements (Optional) [dict]: A dictionary for namespace of the elements, default creates a
                new dictionary with the current `cls` id mapped to the instance.
        Returns:
            Element: A newly created instance of `Element`.
        Note:
            The `cls` passed to the method must be a subclass of `Element` or `Element` itself.
            The `owner` if provided, must be an instance of `Element` or its subclass.
        """
        self = super().__new__(cls)
        owner = self.__owner__ = kwargs.pop("owner", None)
        self.__owned_elements__ = []
        self.__id__ = kwargs.pop("id", id(self))
        self.model = typing.cast(Element, owner).model if owner is not None else self
        all_elements = self.__all_elements__ = kwargs.pop(
            "all_elements", {id_of(cls): self}
        )  # create a namespace for the elements in the element
        cls.__create_owned_elements__(self, all_elements)
        return self

    @staticmethod
    def __new__(
        cls: type["Element"], *args: typing.Any, **kwargs
    ) -> typing.Union["Element", typing.Callable[[], "Element"]]:
        """
        Creates a new instance or a callable to create an instance of the provided class 'cls'.
        This customized static method handles the logic required to initialize a new instance of 'cls' 
        with a focus on associating related 'Element' objects within an elements hierarchy. 
        Initialization is deferred until the root element is reached or all associations are processed.
        Parameters:
            cls (type['Element']): The class of the element for which a new instance or a
                callable to create a new instance is being created.
            *args (typing.Any): Variable length argument list which is currently not used in the method.
            **kwargs (typing.Any): Arbitrary keyword arguments which provide initialization data for 
                attributes of the instance and associated elements.
        Returns:
            typing.Union['Element', typing.Callable[[], 'Element']]: Returns either an initialized 
                instance of 'Element' if no owner is found (root element), or a lambda function 
                that will return the new instance, to prevent automatic calling of '__init__'.
        Note:
            The new instance creation in this function is implemented through the cls.__create__ method.
        """
        self = cls.__create__(**kwargs)
        if owner_of(self) is None:
            for element in reversed(self.__all_elements__.values()):
                for name, value in associations_of(element).items():
                    value = self.__all_elements__[id_of(type(value))]
                    setattr(element, str(name), value)
                if element is not self:
                    element.__init__(**kwargs.pop(qualified_name_of(element), {}))
            # this is the root element of the element, so we can start initializing
            return self
        # a hack to prevent __init__ from being called
        return lambda _self=self: _self

    @classmethod
    def __create_owned_elements__(cls, self, all_elements: dict[int, "Element"]):
        """
        A class method that initializes owned elements for an instance based on class owned elements template.
        This method iterates through a list of element IDs specified in the class's `__owned_elements__` attribute,
        creates instances of these elements, and adds them to the `all_elements` dictionary with the
        ownership set to the current instance. It overrides the elements' initialization by using a
        direct function call to bypass calling `__init__`, ensuring that the elements are created without
        invoking their constructors. The newly created owned element instances are then added to the
        instance's `__owned_elements__` list.
        Args:
            self (self_type): The instance of the class that will own the newly created elements.
            all_elements (dict[int, 'Element']): A dictionary mapping element IDs to `Element` objects where
                the `Element` is a placeholder for the actual element class. This dictionary is updated with
                the newly created elements.
        Raises:
            KeyError: If an owned_element_id in `__owned_elements__` does not exist in `__all_elements__`
        """
        for owned_element_id in cls.__owned_elements__:
            owned_element = cls.__all_elements__[owned_element_id]
            instance = owned_element(
                owner=self,
                all_elements=all_elements,
            )()  # using the extra function call to prevent __init__ from being called
            all_elements[owned_element_id] = instance
            self.__owned_elements__.append(owned_element_id)
